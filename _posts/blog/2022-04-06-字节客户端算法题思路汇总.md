---
layout:     post
title:     字节客户端算法题思路汇总（2022.04.06 持续更新中）
description:     Project JOB
date:     2022-04-06
author:     POt
header-img:     img/post-bg-kuaidi.jpg
catalog: true
category: blog
tags:     
    -   
        -   

    -   

---

## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)(八成熟)

```java
ListNode pre = null;
ListNode cur = head;
```

递归：

```java
public ListNode reverseList(ListNode head) {
        return reverse(null, head);
    }
    ListNode reverse(ListNode pre, ListNode cur){
        if(cur == null){
            return pre;
        }
        ListNode temp = cur.next;
        cur.next = pre;
        pre = cur;
        cur = temp;
        return reverse(pre, cur);
    }
```



## [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)(熟，排序)

## [3. 无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/)(熟，滑动窗口)

## [160. 相交链表](https://leetcode-cn.com/problems/intersection-of-two-linked-lists/)(熟，HashSet)

## [25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)(不熟)

## [146. LRU 缓存](https://leetcode-cn.com/problems/lru-cache/)(五成熟)

```java
class LRUCache {

    DoubleLinkedList doubleLinkedList;
    Map<Integer, Node> map;
    int cap;
    public LRUCache(int capacity) {
        doubleLinkedList = new DoubleLinkedList();
        map = new HashMap<>();
        cap = capacity;
    }
    
    public int get(int key) {
        if(!map.containsKey(key)){
            return -1;
        }
        int val = map.get(key).val;
        put(key, val);
        return val;
    }
    
    public void put(int key, int value) {
        Node node = new Node(key, value);
        if(map.containsKey(key)){
            doubleLinkedList.delete(map.get(key));
            doubleLinkedList.addFirst(node); 
            map.put(key, node);
        }
        else{
            if(map.size() == cap){
                int deleteVal = doubleLinkedList.deleteLast();
                map.remove(deleteVal);
            }
            map.put(key, node);
            doubleLinkedList.addFirst(node);
        }
    }
}

 class Node{
     Node prev;
     Node next;
     int key;
     int val;
     public Node(int key, int val){
         this.key = key;
         this.val = val;
     }
 }
 class DoubleLinkedList{
     Node head;
     Node tile;

     public DoubleLinkedList(){
         head = new Node(0, 0);
         tile = new Node(0, 0);

         head.next = tile;
         tile.prev = head;
     }

     void addFirst(Node newNode){
         newNode.next = head.next;
         newNode.prev = head;

         head.next.prev = newNode;
         head.next = newNode;
     }

     int delete(Node node){
         int key = node.key;
         node.next.prev = node.prev;
         node.prev.next = node.next;
         return key;
     }

     int deleteLast(){
         int val = delete(tile.prev);
         return val;
     }
 }
```

