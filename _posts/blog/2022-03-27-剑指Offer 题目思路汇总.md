---
layout:     post
title:     剑指Offer 题目思路汇总（2022.3.28 持续更新中）
description:     Project JOB
date:     2022-03-28
author:     POt
header-img:     img/post-bg-kuaidi.jpg
catalog: true
category: blog
tags:     
    -   
        -   

    -   

---

## JZ3 数组中重复的数字

描述：

数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字

1. List.contains() 时间负责度O(nlogn);
2. 快速排序 + 遍历

## **JZ4** **二维数组中的查找**

二维数组array中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。

1. 暴力 O(n2)
2. 二分查找 因为二维数组是有序的，即对于每一行，从上到下逐行递增，对于每一列，从右到左，逐行递减，利用该性质，可以**从右上角开始**，**类二分做法** O(n)

## **JZ5** 替换空格

请实现一个函数，将一个字符串s中的每个空格替换成“%20”。

例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

1. 遍历，用StringBuilder替换  O(n)

## **JZ6** **从尾到头打印链表**

输入一个链表的头节点，按链表从尾到头的顺序返回每个节点的值（用数组返回）。

1. 用正序遍历装载List中，倒序输出
2. 用栈先进后出的特性（Stack要自己导包）

## JZ7 重建二叉树

先序遍历 -> 中左右

中序遍历 -> 左中右

数组拷贝函数：Arrays.copyOfRange()【左闭右开】

终止条件：如果pre.length == 0，返回null。如果pre.length == 1 返回 return new TreeNode(pre[0]);

## **JZ8** **二叉树的下一个结点**

给定一个二叉树其中的一个结点，请找出中序遍历顺序的下一个结点并且返回。注意，树中的结点不仅包含左右子结点，同时包含指向父结点的next指针。

中序遍历，如果有右节点，则找到右节点的最左节点返回。如果没有右节点，则找到父节点返回

## **JZ9** **用两个栈实现队列**

用两个栈来实现一个队列， 队列中的元素为int类型。保证操作合法，即保证pop操作时队列内已有元素。

一个栈做res，一个栈倒腾一下

## **JZ10** **斐波那契数列**（不熟）

现在要求输入一个正整数 n ，请你输出斐波那契数列的第 n 项。

1. 递归法

   ```
    public int Fibonacci(int n) {
           if(n == 0 || n == 1){
               return n;
           }
           else{
               return Fibonacci(n - 1) + Fibonacci(n - 2);
           }
       }
   ```

2. 动态规划

   ```
   public int Fibonacci(int n) {
           int[] dp = new int[n];
           dp[0] = 1;
           dp[1] = 1;
           for(int i = 2; i < n; i++){
               dp[i] = dp[i - 1] + dp[i - 2];
           }
           return dp[n - 1];
       }
   ```


## **JZ11** **旋转数组的最小数字**

有一个长度为 n 的非降序数组，比如[1,2,3,4,5]，将它进行旋转，即把一个数组最开始的若干个元素搬到数组的末尾，变成一个旋转数组，比如变成了[3,4,5,1,2]，或者[4,5,1,2,3]这样的。请问，给定这样一个旋转数组，求数组中的最小值。

1. 遍历，找到前一个比后一个大的，返回
2. 二分法

## **JZ12** **矩阵中的路径**

请设计一个函数，用来判断在一个n乘m的矩阵中是否存在一条包含某长度为len的字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则该路径不能再进入该格子。

1. 回溯法，上下左右进行dfs

## **JZ13** **机器人的运动范围**

地上有一个 rows 行和 cols 列的方格。坐标从 [0,0] 到 [rows-1,cols-1] 。一个机器人从坐标 [0,0] 的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于 threshold 的格子。 例如，当 threshold 为 18 时，机器人能够进入方格  [35,37] ，因为 3+5+3+7 = 18。但是，它不能进入方格 [35,38] ，因为 3+5+3+8 = 19 。请问该机器人能够达到多少个格子？

1. 回溯法 机器人可以返回，所以只需要累加count就可，不用回溯时count--

## **JZ14** **剪绳子**

给你一根长度为 n 的绳子，请把绳子剪成整数长的 m 段（ m 、 n 都是整数， n > 1 并且 m > 1 ， m <= n ），每段绳子的长度记为 k[1],...,k[m] 。请问 k[1]*k[2]*...*k[m] 可能的最大乘积是多少？

1. 动态规划法，dp[ i ] dp表示从0 - i为止的最大乘积，两种可能，一种是剪了，一种是没剪，**是i后面为基准**

   ```java
   int temp = Math.max(dp[j] * (i - j), j * (i - j));
                   dp[i] = Math.max(dp[i], temp);
   ```

## **JZ15** **二进制中1的个数**

输入一个整数 n ，输出该数32位二进制表示中1的个数。其中负数用补码表示。

1. 位运算

   ```
   public int NumberOf1(int n) {
           int sum = 0;
           int z = 0;
           while(z != 32){
               if(n % 2 == 1 || n % 2 == -1){
                   sum++;
               }
               z++;
               n = n >> 1;
           }
           return sum;
       }
   ```

## **JZ16** **数值的整数次方**（不熟）

实现函数 double Power(double base, int exponent)，求base的exponent次方。

背

```java
public double Power(double x, int n) {
        // 快速幂法
        if(x == 0) return 0;
        long b = n;
        double res = 1.0;
        if(b < 0) {
            x = 1 / x;
            b = -b;
        }
        while(b > 0){
            if((b & 1) == 1){
                res = res * x;
            }
            // x的(2的m次方)
            x *= x;
            b >>= 1;
        }
        return res;
  }
```

## **JZ17** **打印从1到最大的n位数**

输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。

1. 计算出容量，新建数组，res[i] = res[i - 1] + 1

## **JZ18** **删除链表的节点**

给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。返回删除后的链表的头节点。

1. pre保存前一个指针，遍历找到要删除的指针，用pre.next指向head.next，将head.next置为null

## **JZ19** **正则表达式匹配**（hard，不熟）

请实现一个函数用来匹配包括'.'和'*'的正则表达式。

1.模式中的字符'.'表示任意一个字符

2.模式中的字符'*'表示它前面的字符可以出现任意次（包含0次）

1. 动态规划

## **JZ20** **表示数值的字符串**（hard）

## **JZ21** **调整数组顺序使奇数位于偶数前面(一)**

实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前面部分，所有的偶数位于数组的后面部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。

1. 遍历法：建立两个List，一个存储奇数，一个存储偶数，两个List合并
2. 冒泡排序：遍历n2次，如果一个j为偶数，j + 1位奇数，那么就进行交换

## **JZ22** **链表中倒数最后k个结点**

输入一个长度为 n 的链表，设链表中的元素的值为 ai ，返回该链表中倒数第k个节点。

如果该链表长度小于k，请返回一个长度为 0 的链表。

遍历链表，第一次遍历记录count，第二次遍历直到第K个节点，返回pHead