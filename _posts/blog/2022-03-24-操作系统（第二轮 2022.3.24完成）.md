---
layout:     post
title:     操作系统（第二轮 2022.3.24 完成）
description:     Project JOB
date:     2022-03-24
author:     POt
header-img:     img/post-bg-kuaidi.jpg
catalog: true
category: blog
tags:     
    -   
        -   

    -   

---

## 内核态和用户态

### 内核态和用户态的区别

**最简单的运行程序的方式是直接执行，直接执行会有以下问题**

* **如何限制代码行为**
* **运行程序时如何切换到另一个程序，进程调度时OS的权限。**

所以引入内核态和用户态两种行为

内核态的权限较高，用户态的权限较低

用户态只能访问部分内存，不能进行IO操作，不能占有CPU资源

内核态的可以访问全部内存，可以进行IO操作，可以完全占有CPU资源

### 什么时候会陷入内核态

1. 系统调用：**是用户进程主动发起的操作，发起系统调用，陷入内核，由OS执行系统调用，再返回给进程**
2. 中断 **中断和异常是被动的，无法预测发生时机，IO中断、外部信号中断等**
3. 异常 **中断和异常都会通过中断向量表来找到相应的处理程序来进行处理**

### C访问空指针会不会陷入内核态

会

**访问指针相当于访问一个虚拟地址，硬件会将虚拟地址映射到真实的物理内存中，如果映射失败，会抛出一个错误异常，此时会从用户态转为内核态进行处理。**

## 系统调用

Linux内核中设置了一组用于**实现各种系统功能的子程序，称为系统调用。**用户可以通过系统调用命令在自己的应用程序中调用它们。**从某种角度来看，系统调用和普通的函数调用非常相似**。区别仅仅在于**，系统调用由操作系统核心提供，运行于核心态;而普通的函数调用由函数库或用户自己提供，运行于用户态。**

## 陷阱、中断、异常、信号

### 前言，为什么会产生陷阱、中断、异常、信号（异常控制流）

**程序是由一条一条指令构成的，顺序执行指令叫做控制流。在执行的过程中，系统也会发生一些异常情况。处理这些异常的时候，会打断进程的控制流，转而执行相应的处理程序，执行完毕在返回，叫异常控制流。**

### 陷阱、中断、异常、信号的产生来源

陷阱**是有意造成的异常**，用户自己设定的，目的是执行系统调用，**进行系统调用时，会通过系统调用唯一的整数号，对应跳转表中的偏移量，从而执行相应的系统调用**     *（软中断）* 

中断是不可预知的，由外部设备所造成的，由于中断独立于当前的程序，**中断是异步事件**。**在中断时，操作系统会根据中断号，在中断描述表中查找并执行相应的中断处理程序，当处理程序返回后，进程继续执行下一条指令，就好像没发生过一样。**

异常是程序自己抛出的，是一种错误情况，**可能被处理程序修正，也可能直接终止应用程序，异常是同步的。**

信号一种更高级的异常形式，也会改变进程的控制流。

![](https://s2.loli.net/2022/03/23/2Ven7urIWJc5y3A.png)

### 陷阱、中断、异常、信号的处理流程

### 常见的陷阱、中断、异常、信号有哪些

### Ctrl + C、Ctrl + Z、kill -9的原理

## 进程与线程

### 进程与线程的区别

1. 进程是系统分配资源的基本单位，线程是CPU分配资源的基本单位

2. 线程依赖于进程存在，一个进程可以拥有n个线程

3. 线程通信比较方便**（通过共享内存）**，而进程之间需要用IPC进行通讯

4. 多进程的程序相对稳定，一个进程崩溃不会影响整个程序。多线程程序一个线程崩溃，程序均无法运行

5. 进程耗费系统资源，线程几乎不耗费系统资源

6. **进程切换开销很大，线程切换开销很小**

   | 进程     | 线程                                            |                                                              |
   | -------- | ----------------------------------------------- | ------------------------------------------------------------ |
   | 资源     | 进程是一个**拥有资源**和**执行任务**的单元体。  | 线程是一个**执行任务**的单元体，**不拥有资源**，线程之间**共享地址空间** |
   | 切换开销 | 开销很大                                        | 开销很小                                                     |
   | 通信     | [IPC](https://imageslr.com/2020/02/26/ipc.html) | 共享内存                                                     |
   | 健壮性   | 健壮，多个进程之间不会互相干扰                  | 不健壮，一个线程出错会终止整个进程                           |

### 为什么需要线程

**进程切换是一个开销很大的操作，主要开销包括：**

1. **上下文切换：保存和恢复相关寄存器的内容**
2. **与进程相关的数据结构更改：存储页表、文件描述符、队列等**

**所以如果我们只切换必须的，和处理机相关的信息就可以减少开销，由此引入线程**

线程是CPU分配资源的基本单位，进程依托于线程而存在

### 线程上下文切换过程

将上下文保存到TCB（Thread Control Block）中，同时恢复另一个进程的上下文

线程只需要切换和处理机相关的上下文就可以了，**开销少，提升效率**

### 线程的优缺点

* 线程的优点：**开销少，提升效率**，通信较为方便，可相互共享进程的代码、变量、文件描述符等
* 线程的缺点：多线程程序中，一个线程出错，就会结束整个进程。**同一进程中的多个线程共享内存，会有并发以及安全问题。**

### 同一进程中线程共享的与独占的资源

共享：

* **内存空间**
  * 代码
  * 公共数据
  * 堆
* **文件描述符**
* **信号处理器**
* **进程ID**
* ...

独享资源以及为什么要独占：

* **线程ID**：在本进程中唯一，进程用来标识此线程
* 一组寄存器的值
* **栈**：每个线程中的函数调用时独立的，因此需要有独立的栈
* **错误返回码**：系统调用或库函数发生错误时，会设置全局变量`errno`，各个线程的错误返回码应该是独立的
* 信号屏蔽码：每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理

### 线程的实现方式

线程也像进程一样有多个状态：运行态、就绪态、阻塞态

**线程实现的方式有三种：**

* **在内核中实现**
* **在用户空间中实现**
* **混合方式实现**

### 线程池介绍、应用背景

## 进程的调度

### 进程的状态

三态：就绪态、运行态、阻塞态

* 就绪态：该进程除了CPU资源外其余资源均已准备完毕，等待分配CPU资源
* 运行态：拥有CPU资源，并且正在运行程序
* 阻塞态：该进程在等待某种条件，在满足条件前无法运行

五态：新建态、就绪态、运行态、阻塞态、终止态

七态：

- **挂起就绪状态：进程在外存中，但是只要被载入内存就可以执行**

- **挂起阻塞状态：进程在外存中并等待一个事件，即使被载入内存（激活）也无法运行**

  ![](https://imageslr.com/media/15941900183711.jpg)

### 调度算法

**调度算法的分类：**

* 按照CPU的分配方式：**非抢占式、抢占式**
* 按照系统的分时方式：**批处理系统、可交互系统**

### 批处理系统、可交互系统的调度算法

调度算法的目标：

* **吞吐量**
* **周转时间**
* **CPU利用率**

批处理系统：

1. 先来先服务：顾名思义，谁先来谁先服务，可能会有饥饿现象；**对短作业不友好**；**对IO密集型进程不利**；**非抢占式**
2. 最短作业优先：哪个进程运行时间最短，就先进行服务。对长进程不友好，可能会有饥饿现象
3. 最短剩余时间优先：哪个剩余时间最少就先进行服务，**对长作业不公平，导致饥饿问题，同“最短时间优先”**
4. 最高响应比算法：**响应比 = 等待时间 / 运行时间**，**同时考虑了等待时间和执行时间，及考虑短作业也考虑长作业**

可交互式系统

1. 时间片轮转：按照先来先服务排成一个循环队列。定义一个时间片，给每个进程都分配一个时间片大小的运行时间，如果在一个时间片内没有运行完，则排到队尾。**没有饥饿问题**。**时间片小，IO大**，**时间片大，响应时间太长，对短作业不利**
2. 优先级**调度**算法：（**同级别时间片轮转**）根据作业时间给进程分级，每个级别拥有不同的运行时间，级别可根据运行情况和时间动态调整
3. **多级反馈队列**：**优先级高的队列先执行，优先级越高，时间片越短。**

### 僵尸进程、孤儿进程、守护进程

前提：当一个进程*由于某些原因被终止时，内核并不是立即把它从系统中清除。进程会保持在一种“已终止”的状态中，直到被它的父进程回收。*当父进程回收已终止的子进程时，内核会抛弃已终止的进程，此时该进程就不存在了。

僵尸进程：（停止运行）**是指终止但未回收的进程**，如果子进程退出，而父进程没有调用`wait()`，或者`waitpid()`来回收，那么就会产生僵尸进程。僵尸进程是一个已经死亡的进程，但是其进程描述符仍然保存在系统的进程表中

孤儿进程：父进程在子进程结束前自行结束，这时候子进程变成了孤儿进程，系统会扫描是否存在子进程，如果存在会通过**init()进程**对孤儿进程进行托管和转交，孤儿进程不会对系统造成危害

**守护进程：在后台执行的电脑程序。此类程序会被以进程的形式初始化**

## 线程和进程的通信方式

### 信号、管道、信号量、共享内存、消息队列

#### 信号

信号是Linux系统**响应某些条件而产生的一个事件**，**由操作系统事先定义**，接收到该信号的进程可以采取自定义行为。

信号来源分为硬件来源和软件来源

* 硬件来源：如按下Ctrl + C，除0，非法内存访问等等
* 软件来源：kill命令...

**一般的信号都是由一个错误产生的，除0**

进程如何发送信号？

* **操作系统提供发送信号的系统调用**
* 该系统调用会将信号放到目标进程的信号队列中

如何接受信号？

* 每个进程有一个信号队列，存放其他进程发给它、等待它处理的信号

用户对信号的处理：处理信号、忽略信号、不处理也不忽略

#### 管道

* 匿名管道

  **半双工**、如果要同时进行通信要走两条管道。**只能用于亲缘进程之间的传输**，**管道适合传输大量信息**

* 命名管道（FIFO）

  可用于没有亲缘的进程间，`mknode()` `mkfifo()`

#### 信号量

信号量是一种特殊的变量，**对它的操作都是原子的**。PV操作，是保证同步互斥的，同一时间只能有一个进程访问临界资源。只有0和1

#### 共享内存

**不同进程可以将同一段共享内存映射到自己的地址空间，然后像访问正常内存一样访问它，优点是简单且高效，但是会存在并发问题。**

#### 消息队列

**消息队列是一个消息的链表，保存在内核，每一个消息都是一个数据块**

#### 套接字（Socket）

不同计算机的进程之间可以使用Socket通信，内含主机地址和端口号

### 各种通信方式的原理、适用场景

## 锁的类型与实现

### 了解哪些类型的锁

**互斥锁、读写锁、自旋锁、条件锁**

### 互斥锁的实现方式

### 读写锁的实现方式

## 进程的同步与互斥

### 临界资源和临界区的概念

临界资源：多个进程同一时间只能有一个进程访问的资源。

临界区：多个进程同一时间只能有一个进程访问临界资源的代码块。

### 同步和互斥的概念

同步：多个进程为了合作而使进程按照一定顺序进行运行，一个进程运行时，其余进程等待

互斥：同一时间只能有一个进程进入临界区

### 临界区的管理规则

* **同一时间只能有一个进程访问临界区**
* **不应该对CPU的速度和数量做任何假设**
* **临界区外运行的进程不得阻塞其他进程**
* **不得使进程无限等待进入临界区**

### 信号量和PV操作

信号量：一般成对出现，一个信号量表示**缓冲区**已经使用了多少空间，另一个信号量表示**缓冲区**还有多少空间剩余

P操作，信号量-1

V操作，信号量+1

### 原子操作的原理

原子（atom）本意是“**不能被进一步分割的最小粒子**”，而原子操作（atomic operation）意为”**不可被中断的一个或一系列操作”** 。

32位IA-32处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。

### volatile解决什么问题

### 一些常见的并发问题

#### 生产者消费者问题

#### 读者写者问题

#### 浴室洗澡问题

#### 哲学家就餐问题

## 死锁的预防、检测、避免、解除

### 死锁产生的四个必要条件

1. 互斥
2. 占有等待
3. 非抢占
4. 循环等待

### 如何预防、检测、避免、解除死锁

预防：破坏产生死锁的四个条件（占有等待：预先分配；非抢占：允许强行抢占；）

检测：画出资源分配图， 检测是否存在环路，如果有环路要对其进行化简

避免：银行家算法，允许系统存在四个必要条件，但每当进程提出资源申请时，要判断是否会产生死锁

解除：**回退、抢占、kill**


## 物理内存管理

###  不同的内存分配技术及其优缺点
#### 引进内存分配技术的原因：
内部碎片和外部碎片：

**内部碎片是固定分区法产生的**，指被占用分区上未被利用的空间，由于该分区被占用，因此无法被分配使用
**外部碎片是动态分区法产生的**，*指被占用分区之间的小空间*，虽然可以被使用，但是由于太小而无法被分配


* 固定分区法（等长、不等长）

    **每个分区大小相同**，在系统启动时分配好，系统运行期间保持不变；每次给进程分配一整块区域，**因此进程的大小必须 ≤ 分区的大小**
    * 优点：系统需要维护的管理信息非常少
    * 缺点：不同进程需要的空间不同，内部碎片多，浪费空间

* 动态分区法

    **在系统运行中，根据每个进程需要的空间大小确定分区大小**
    
    * 并发执行的程序数量不受限制，只取决于是否有大小合适的内存块可以分配
    * 管理空闲快的复杂度增加；分配算法的时间开销增加，可能需要遍历多次才能找到合适的内存块

* 页式内存管理

    把固定分区面积缩小，一个进程可使用多个分区；进程被分割成若干块，装入内存中的几个分区中，物理上无需相连，逻辑上通过页表关联。这是一种内存的不连续分配方法（**进程和内存被分隔成一样的大小**）
    
    * 优点：不存在任何外部碎片，只在每个进程的最后一个页框中存在内部碎片

* 段式内存管理

    按照程序代码段将程序分割为n段，每个段独立载入到内存的不同区间中。
    
    * 优点：分页不考虑每个页中内容的意义，而分段是按照逻辑关系划分
    * 缺点：每个段必须连续、全部加载到内存中

* 段页式内存管理

    把分段和分页两种方式结合，先把程序按照逻辑意义分成段，然后每个段再分成固定大小的页
![](https://s2.loli.net/2022/03/20/N7wedIGSDlKh6PM.jpg)

### 不同的动态分区放置算法及其优缺点

* 最佳适应算法

    * 检查所有空闲分区，选择和新进程申请内存大小最接近的空闲分区
    * 优点：该算法保留大的空闲区
    * 缺点：检查所有空闲分区需要时间、外部碎片多、可以采用内存紧凑的方法，将被使用的分区都移动到一起，减少外部碎片。但是移动内存中的代码和数据也需要很多时间

## 虚拟内存管理
### 虚拟内存的思想 / 实现方法

* **在系统中为每个程序定义一个虚拟地址空间，虚拟地址空间中的地址时连续的**

* 虚拟地址空间被分割成多个块，每个块被称为一个**页或者页面**

* 物理内存被分割成和页面大小相同的多个区域，叫做**页框**

* **程序加载时，可将任意一个页面放入内存中的任意一个页框**

* **CPU的硬件负责将虚拟地址映射到物理内存中的地址（页面 -> 页框）**

* **程序的整个地址空间无需全部载入物理内存，还有部分暂时存储在外存上，需要时再换入内存**

* 如果程序引用到一部分不在物理内存中的虚拟地址时，会发生**缺页中断**，由操作系统负责将缺失的页面载入到页框中，并重新执行失败的指令

  ![](https://imageslr.com/media/16013686415116.jpg)

### 暂时不在内存中的数据存在哪里？

**会存储在交换分区（swap）中**。当内存不足时，操作系统先把内存中暂时不用的数据，存到硬盘的交换空间，释放内存空间

### 虚拟地址的映射

页表：每个进程 有一个页表，**描述该进程每个页面对应的页框号，以及该页面是否已经被载入到内存**

![](https://imageslr.com/media/16013673021620.jpg)

### TLB的原理

TLB，转换检测缓冲区（translation-lookaside buffer）（**人话：页框号缓存）**

在现代操作系统中，页表的个数是很多的，每次执行语句时都需要先查询页表，将虚拟地址转换为物理地址，这样时间开销很大，所以引入TLB

工作流程：如果页面号在TLB中，得到页框号，访问内存；否则，从内存中的页表中得到页框号，将其存入TLB，访问内存。（有点类似于DNS？？）

### 虚拟地址到物理地址的翻译过程
### 缺页中断的处理

应用程序访问未加载到内存中的页面时，会发生缺页中断。操作系统会将缺失的页面调入页框中，然后重新执行引起异常的指令。

缺页异常（exception），直接执行异常处理：异常是程序自己抛出的，是一种错误情况，**可能被处理程序修正，也可能直接终止应用程序，异常是同步的。**

### 不同的淘汰算法及其适用场景

常见的淘汰算法：

* 最佳置换算法/ 最优策略（OPT）：选择以后再也不会用到的页面进行淘汰；如果都会用到，就选择那些再次使用的时间 距离现在最远的页面进行淘汰。这是一种理想情况下的页面置换算法，实际上不可能实现。可以作为评测其他淘汰策略的标准。

* **先进先出法（FIFO）**：换出最早进入进入页框的页面

  * 优点：简单
  * 缺点：性能不好 ，有可能淘汰常用的页面
  * 适用场景：数据只使用一次，将来不太可能使用；对数据时效性有要求的情况

* 第二次机会置换法（SCR）：对FIFO的改进，每个页面访问两次后淘汰 

  ![](https://imageslr.com/media/16013705538675.jpg)

* 时钟置换法（Clock）：对第二次机会置换法的改进。第二次机会置换法需要在链表中移动页面，而时钟置换法将页面保存在环形链表中，只需要后移对头指针，就相当于是把原来的对头放到队尾了

  ![](https://imageslr.com/media/16013705785727.jpg)

* **最近最少使用法（LRU：Least Reacently Used）**：优先淘汰最久未访问的页面

  * 优点：LRU的性能较好
  * 缺点：存在缓存污染的问题（缓存污染：由于偶发性或周期性的冷数据批量查询，热点数据被挤出去，导致缓存命中率下降）
  * 适用场景：访问分布未知的情况

* **最近最不经常使用法（LFU：Least Frequently Used）：优先淘汰访问频率最少的页面**

  * 优点：能够避免缓存污染问题对LRU的命中影响
  * 缺点：存在**访问模式**问题，如果访问内容发生较大变化，LFU需要用更长时间适应。

总结：**最常使用的是LRU**

## 虚拟地址空间的组成部分

### 虚拟地址空间的组成部分

内核空间和用户空间。内核空间主要存放的是内核代码和数据，用户空间主要存放的是用户程序代码和数据。

![](https://imageslr.com/media/16050117063362.jpg)

### 栈的作用，增长方向

**用户栈就是函数调用栈**，**作用为保存局部变量**，保存寄存器的值，返回函数值和地址

### 堆的作用，增长方向

堆内存允许程序在运行态时动态申请某个大小大小的内存空间。申请的内存在函数退出后仍然保留

如果反复向操作系统申请堆内存而不释放，有可能会导致内存泄漏。

### 栈和堆的区别

1. 增长方向：栈向低地址方向增长，堆向高地址方向增长
2. 申请回收：栈自动分配和回收，堆需要手动申请和释放
3. 生命周期：栈的数据仅存在于函数运行过程中，堆的数据只要不释放就一直存在
4. 连续分配：栈是连续分配的，堆是不连续的，容易产生内存碎片
5. 空间大小：栈的大小是有限的（如默认 8M，Linux 上通过 `ulimit -s` 查看），而堆的空间较大，受限于系统中有效的虚拟内存

## 缓冲区溢出问题

### 什么是缓冲区溢出？

**对越界的数组元素的写入会破坏存储在栈中的状态信息**，缓冲区溢出会破坏程序运行，也可以被用来进行攻击计算机，如使用一个指向攻击代码的指针覆盖返回地址

## I/O模型

### 五种I/O模型

**阻塞IO、非阻塞IO、信号驱动式IO、IO多路复用、异步IO**

### 同步I/O和异步I/O

区别在于：将数据从内核复制到用户空间时，用户进程是否会阻塞

### 阻塞IO和非阻塞IO

区别在于：进程发起系统调用后，是会被挂起直到收到数据后在返回、还是立即返回成功或错误

### IO的多路复用：select poll epoll

## 上下文切换

**由于中断处理，用户态切换**，**多任务处理等原因会导致cpu从一个线程切换到另一个线程时，切换过程需要保存当前线程的状态并且恢复另一个线程的状态。**

上下文切换的代价是高昂的，上下文切换的延迟取决于不同的因素，一次切换大概的耗时为60~100纳秒，每个CPU核心平均每纳秒能执行12条指令，所以一次上下文切换会耗费720~1200条指令的延迟时间。而且在实际程序中，上下文切换会占用大量程序执行的时间。

如果存在跨核上下文切换，会导致cpu缓存失效（cpu从缓存访问数据的大致成本在3到40个时钟周期，从内存访问数据的成本在100到300个时间周期），这时的切换成本会更加高昂。

## 协程

### 什么是协程

协程是一种轻量化的线程（**用户态线程**），用户在堆中模拟出协程的栈空间。

理解：进程和线程的切换还是要经过从用户态到内核态再到用户态这一过程的，而协程呢，是**用户态线程**，也就是说它全程**运行在用户态上，避免了用户态到内核态的切换**，在切换时只需要进行栈空间的交换并且恢复一些寄存器的状态即可完成切换。

### 进程、线程、协程有什么区别

进程：系统资源的基本单位

线程：CPU资源的基本单位

协程：用户态线程

### 协程为什么效率高

切换上下文时**只需要交换栈空间并恢复协程的一些相关寄存器状态**，就可以实现上下文切换，**没有了从用户态切换到内核态的切换成本，执行效率高效**

### 协程的实现原理

1. 堆中模拟栈，从而实现了一个用户态的线程
2. 调度器，负责协程的调度和上下文切换

### 协程切换哪些数据

### 什么时候用协程，什么时候用线程

### 协程的栈空间大小

- 寄存器，包括 PC (指令位置) 和 CPU 寄存器 (参数、上下文…)
- 栈指针
- 返回值
