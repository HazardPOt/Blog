---
layout:     post
title:     多线程与并发（2022.04.03 持续更新中）
description:     Project JOB
date:     2022-04-03
author:     POt
header-img:     img/post-bg-kuaidi.jpg
catalog: true
category: blog
tags:     
    -   
        -   

    -   

---

## Java内存模型与volatile关键字

### Java内存模型

Java内存模型（Java Memory Model）简称JMM。JMM本身是一个抽象概念，并非真实存在于Java虚拟机中。它的目的仅仅是定义了程序中各种变量的访问规范，**可以理解为JMM定义的就是线程访问共享变量的方式。**

#### 缓存一致性

计算机系统中存在一个CPU的运算速度与内存读写速度不匹配的情况，即CPU的运算速度远比内存的读写速度来得快。由于读写速度慢，严重拖累了计算机的运行效率，为了解决这一问题，现代计算机系统在CPU与内存中介加入了一层**高速缓存**，而高速缓存的速度与CPU的速度相当。加入高速缓存后，需要将要运算的数据从内存中搬运到高速缓存中，接着CPU对数据进行处理，然后将处理好的数据写入到高速缓存，最后再同步回内存。

绝大多数都是多CPU计算机，在多CPU系统中，每个处理器都有自己的高速缓存，他们又共享同一个主内存。

![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/28a5340c92ca49d7a9534c6d7d2d0386~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

当多个处理器的运算任务都涉及到同一块主内存区域时，将可能导致**各自缓存数据不一致的问题**。例如，处理器1与处理器2都从主内存读取了同一个数据分别存储到自己的高速缓存区域，然后，两个处理器都对这一数据进行了修改。那么再同步回主内存的时候应该以哪条数据为准呢？这一问题就是**缓存一致性问题**

#### Java内存模型（JMM）

**JMM规定所有变量都存储在主内存中，每条线程还有自己的工作内存。线程的工作内存中保存了被线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据。不同线程之间也无法直接访问对方的工作内存中的变量，线程间变量值的传递需要通过主内存来完成。** 也就是说Java线程之间的通信采用的是共享内存。

每条线程都有自己的工作空间，而共享变量存储在共享内存中。**线程在运行时会首先将共享内存中的数据读取到自己的工作内存**，即在线程的工作内存中复制了一个共享变量的副本，然后对其进行计算，计算完成后线程会将自己工作内存中的这个共享变量副本同步回主内存。线程、工作内存、与主内存的关系如下图所示：

![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/366a7954b2da4a15aa21a4ee5ed6bf40~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

其实，Java内存模型与Java内存区域并不是同一个层次对内存的划分，可以说两者并没有什么关系。但是它们之间也存在着比较明显的对应关系，**即主内存对应Java堆中的实例数据部分，而工作内存则对应虚拟机栈中的一些区域。**

对于Java内存模型来说，多个线程之间是不是也会存在一样的类似问题呢？那对于这一问题，Java又是怎么解决的呢？

### volatile关键字

解决Java内存模型的缓存一致性问题靠的就是本章的主角--volatitle关键字。volatitle关键字是面试中的常客，虽然它的使用却很简单，但真正理解volatile关键字的人并不多。因为要理解volatile关键字，首先要搞懂Java的内存模型。本章内容，就在上章内容的基础上来认识volatile关键字。

Java并发编程的三大性质：原子性、可见性、有序性。

原子性：指的是一个**不可以被分割的操作**，即这个操作在执行过程中**不能被中断**，要么全部不执行，要么全部执行。一旦执行不能被其他家线程打断

可见性：指的是一个线程**修改了共享变量后，另外线程能立即感知这个变量被修改**

有序性：指程序**按照代码的先后顺序执行**。有时候为了优化性能，编译器会对字节码指令进行重排序。但是能保证重排序后的执行结果与重排序之前是一致的。

volatile经常被用到并发编程的场景中，它的作用有两个：

* **保证可见性**
* **保证有序性**

但是，要注意volatile关键字**并不能保证原子性**。

## synchronized关键字

我们知道volatile关键字可以保证**共享变量的可见性和有序性**，但并不能保证原子性。如果**既想保证共享变量的可见性和有序性，又想保证原子性，那么synchronized关键字是一个不错的选择。**

synchronized的使用很简单，可以用它来**修饰实例方法和静态方法**，**也可以用来修饰代码块**。值的注意的是synchronized是一个**对象锁**，也就是它**锁的是一个对象**。因此，无论使用哪一种方法，**synchronized都需要有一个锁对象**

### synchronized基本使用

#### 修饰实例方法

修饰实例方法只需要在方法上加synchronized关键字即可

```java
public synchronized void add(){
		i++;
}
```

此时，synchronized加锁对象就是这个方法所在的实例本身

#### 修饰静态方法

在静态方法上加上synchronized关键字即可

```java
public static synchronized void add(){
		i++;
}
```

此时，synchronized加锁的对象为**当前静态方法所在类的Class对象**。

#### 修饰代码块

synchronized修饰代码块需要传入一个对象

```java
public void add(){
		synchronized(i){
				i++;
		}
}
```

此时synchronized加锁对象即为传入的这个对象实例。

### Java对象头与Monitor对象

在JVM中，对象在内存中的布局可以分为三个区域，分别是**对象头、实例数据、填充数据**

实例数据：存放类的**属性数据信息**，包括父类的属性信息，这部分内存按4字节对齐

填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍。填充数据不是必须存在的，仅仅是为了字节对齐。

对象头：在HotSpot虚拟机中，对象头又被分为两部分，分别为：Mark Word(标记字段)、Class Pointer(类型指针)。如果是数组，那么还会有数组长度。对象头是本章内容的重点，下边详细讨论。

1. 对象头

   ![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c081fb4576641eaa63e4966703845ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

   Mark Word中有2bit的数据用来标记锁的状态。无锁状态和偏向锁标记位为01，轻量级锁的状态为00，重量级锁的状态为10。

2. Monitor对象

   **Monitor对象被称为管程或者监视器锁**。在Java中，每一个对象实例都会关联一个Monitor对象。这个Monitor对象既可以与对象一起创建销毁，也可以在线程试图获取对象锁时自动生成。当这个**Monitor对象被线程持有后，它便处于锁定状态。**

### synchronized底层实现原理

#### 同步代码块的实现

通过javap -v反编译下面的一段代码

```java
public void add() {
    synchronized (this) {
        i++;
    }
}
```

可以得到如下的字节码指令：

```java
public class com.zhangpan.text.TestSync {
  public com.zhangpan.text.TestSync();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public void add();
    Code:
       0: aload_0
       1: dup
       2: astore_1
       3: monitorenter    // synchronized关键字的入口
       4: getstatic     #2                  // Field i:I
       7: iconst_1
       8: iadd
       9: putstatic     #2                  // Field i:I
      12: aload_1
      13: monitorexit  // synchronized关键字的出口
      14: goto          22
      17: astore_2
      18: aload_1
      19: monitorexit // synchronized关键字的出口
      20: aload_2
      21: athrow
      22: return
    Exception table:
       from    to  target type
           4    14    17   any
          17    20    17   any
}
```

由此可以得出在字节码中会在同步代码块的入口和出口加上**monitorenter**和**moniterexit**指令。当执行到monitorenter指令时，**线程就会去尝试获取该对象对应的Monitor的所有权**，即尝试获得该对象的锁。

当该对象的 monitor 的计数器count为0时，那线程可以成功取得 monitor，并将计数器值设置为 1，取锁成功。如果当前线程已经拥有该对象monitor的持有权，那它可以重入这个 monitor ，计数器的值也会加 1。而当执行monitorexit指令时，锁的计数器会减1。

倘若其他线程已经拥有monitor 的所有权，那么当前线程获取锁失败将被阻塞并进入到_EntryList中，直到等待的锁被释放为止。也就是说，当所有相应的monitorexit指令都被执行，计数器的值减为0，执行线程将释放 monitor(锁)，其他线程才有机会持有 monitor 。

总结：线程有个Monitor对象，这个Monitor对象可以控制线程的锁定状态，当加上Synchronized关键字后，线程会在代码块的入口和出口处加入Monitorenter和Monitorexit指令，执行这个指令后线程会尝试获取Monitor的所有权，即该对象的锁

#### 同步方法的实现

对以下代码进行反编译

```java
public synchronized void add(){
       i++;
}
```

反汇编后可得到如下的字节指令

```java
 public synchronized void add();
    descriptor: ()V
    flags: (0x0021) ACC_PUBLIC, ACC_SYNCHRONIZED
    Code:
      stack=3, locals=1, args_size=1
         0: aload_0
         1: dup
         2: getfield      #2                  // Field i:I
         5: iconst_1
         6: iadd
         7: putfield      #2                  // Field i:I
        10: return
      LineNumberTable:
        line 5: 0
        line 6: 10

复制代码
```

这里没有monitorenter和monitorexit指令，而是在**方法的flag上加入了ACC_SYNCHRONIZED的标记位**，因为整个方法都是同步代码，因此就不需要标记同步代码的入口和出口了。当线程执行到整个方法时，会自动判断是否有这个ACC_SYNCHRONIZED标志，如果有就会尝试获取monitor对象锁，获取monitor所有权

### 重量级所可能会出现的问题

在Linux系统架构中可以分为用户空间和内核，我们的程序都运行在用户空间，进入用户空间就是所谓的用户态

Atomic::cmpxchg_ptr，Atomic::inc_ptr等**内核函数**， 执行同步代码块，没有竞争到锁的对象会park()被挂起，竞争到锁的线程会unpark()唤醒。**这个时候就会存在操作系统用户态和内核态的转换**，**这种切换会消耗大量的系统资源**。试想，**如果程序中存在大量的锁竞争，那么会引起程序频繁的在用户态和内核态进行切换，严重影响到程序的性能**。这也是为什么说synchronized效率低的原因

为了解决这一问题，在JDK1.6中引入了偏向锁和轻量级锁来优化synchronized。

### synchronized锁优化

JDK1.6中引入偏向锁和轻量级锁对synchronized进行优化。此时的synchronized一共存在四个状态：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。

1. 偏向锁

   **在大多数情况下锁不仅不存在多线程竞争关系，而且大多数情况都是被同一线程多次获得**。偏向锁的核心思想是，**如果一个线程获得了锁，那么锁就进入偏向模式**，此时Mark Word的结构也变为偏向锁结构，即将对象头中Mark Word的第30bit的值改为1，并且在**Mark Word中记录该线程的ID**。**当这个线程再次请求锁时，无需再做任何同步操作，即可获取锁的过程**，这样就省去了大量有关锁申请的操作，从而也就提升了程序的性能。所以，对于没有锁竞争的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。

2. 轻量级锁

   轻量级锁优化性能的依据是**对于大部分的锁，在整个同步生命周期内都不存在竞争。** 

   轻量级锁所适应的场景是线程交替执行同步块的场合，**如果存在同一时间访问同一锁的场合，就会导致轻量级锁就会失效，进而膨胀为重量级锁。**

3. 自旋锁

   自旋锁是基于**在大多数情况下，线程持有锁的时间都不会太长**。

   因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，不断的尝试获取锁。空循环一般不会执行太多次，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入同步代码。如果还不能获得锁，那就会将线程在操作系统层面挂起，即进入到重量级锁。

## Java线程的等待与唤醒机制

### 从synchronized锁看线程等待与唤醒

#### 生产者消费者模型

“生产者-消费者”模型是一个典型的线程协作通信的例子。在这一模型中有两类角色，即若干个生产者线程和若干个消费者线程。

用Synchronized实现“生产者-消费者”模型

Bread类

```java
public class Bread{
		public Bread(){
		
		}
}
```

BreadContainer类

```java
public class BreadContainer{
		int CAPACITY = 10;
		LinkedList<Bread> list = new LinkedList<>();
		
		public synchronized void put(Bread bread){
				while(list.size() == CAPACITY){
						try{
								wait();
						}catch(InterruptException e){
								System.out.println(e.toString());
						}
				}
				
				list.add(bread);
				notifyAll();
				System.out.println("Bread was put");
		}
		
		public synchronized void take(){
				while(list.isEmpty()){
						try{
								wait();
						}catch(InterruptException e){
								System.out.println(e.toString());
						}
				}
				
				list.removeFirst();
				notifyAll();
				System.out.println("Bread was take");
		}
		
}
```

Consumer类

```
public class Consumer implements Runnable{
		BreadContainer container;
		public Consumer(BreadContainer container){
				this.container = container;
		}
		container.take();
}
```

Producer类

```java
public class Producer implements Runnable{
		BreadContainer container;
		public Producer(BreadContainer container){
				this.container = container;
		}
		container.put(new Bread());
}
```

Main类

```java
public class Main{
		public static void main(String args[]){
				BreadContainer container = new BreadContainer();
				new Thread(() -> {
						for(int i = 0; i < 100; i++){
								new Thread(new Producer(container)).start();
				}).start();
						}
				new Thread(() -> {
						for(int i = 0; i < 100; i++){
								new Thread(new Consumer(container)).start();
						}
				}).start();
		}
}
```

### wait()与notify() 底层原理

```java
public class Object {

    public final native void notify();

    public final native void notifyAll();

    public final void wait() throws InterruptedException {
        wait(0L);
    } 
    public final native void wait(long timeoutMillis) throws InterruptedException;    

}
```

wait notify notifyAll 都是native方法，底层都是用C写的

#### wait实现

```c++
void ObjectMonitor::wait(jlong millis, bool interruptible, TRAPS) {
    // ...省略其他代码
    
    // 当前线程
    Thread * const Self = THREAD ;
    // 将线程封装成ObjectWaiter
    ObjectWaiter node(Self);
    // 标记为Wait状态
    node.TState = ObjectWaiter::TS_WAIT ;
    Self->_ParkEvent->reset() ;

    Thread::SpinAcquire (&_WaitSetLock, "WaitSet - add") ;
    // 调用 AddWaiter 方法将线程加入到等待队列中
    AddWaiter (&node) ;
    Thread::SpinRelease (&_WaitSetLock) ;
    
    // ...
    
    // 释放 monitor 锁,并将自己挂起
    exit (true, Self) ; 
}
```

可以看到，调用 wait 函数后，线程被封装成了一个 **ObjectWaiter** 对象，并通过**AddWaiter** 函数将线程**加入到等待队列中**,先来看下 AddWaiter 函数的代码，AddWaiter是一个函数，函数初始化一个`_WaitSet`链表，并将node插入到`_WaitSet`的队尾，从代码中也可以看出这个 `_WaitSet` 链表是一个循环的双向链表。

#### notify()实现

在生产者生产完面包后则会**调用notifyAll来唤醒消费者线程**。notifyAll 方法**会唤醒所有线程**，而 notify 只会唤醒一个线程。此处我们以notify为例来看objectMonitor.cpp中 notify 函数是如何唤醒线程的。

在 notify 函数中首先调用了DequeueWaiter 函数， DequeueWaiter 函数的作用是取出`_WaitSet`链表的头结点。

notify 函数接下来的代码判断如果 iterator 不为 NULL 说明存在等待状态的线程，需要将这个等待的线程转入阻塞线程的队列中去。











感谢原作者：

[这一次，彻底搞懂Java内存模型与volatile关键字](https://juejin.cn/post/6967739352784830494)