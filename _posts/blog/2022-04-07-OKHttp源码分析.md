---
layout:     post
title:     OKHttp 源码分析（2022.04.07 持续更新中）
description:     Project JOB
date:     2022-04-07
author:     POt
header-img:     img/post-bg-kuaidi.jpg
catalog: true
category: blog
tags:     
    -   
        -   

    -   


---

```java
OKHttpClient client = new OkHttpClient();
Request request = new Request.Builder().url(http://10.4.17.175:9090/shop).build();
// 通过client的newCall实例化一个RealCall
Call call = client.newCall(request);
Response response = call.execute(call);
String reciverStr = sponse.body().string();
```

## OKHttpClient

基本上 不需要配置任何参数，也就是说基本参数都是默认的，调用的是下面的构造函数。

## Request

构建完OkHttpClient后就需要构建一个Request对象，查看Request的源码你会发现，你找不到public的构造函数，唯一的一个构造函数是这样的。

```java
Request(Builder builder) {
    this.url = builder.url;
    this.method = builder.method;
    this.headers = builder.headers.build();
    this.body = builder.body;
    this.tag = builder.tag != null ? builder.tag : this;
  }
```

这意味着什么，当然我们构建一个request需要用builder模式进行构建，那么就看一下builder的源码。

```java
public Builder newBuilder() {
    return new Builder(this);
  }
//builder===================
public Builder() {
      this.method = "GET";
      this.headers = new Headers.Builder();
    }

Builder(Request request) {
      this.url = request.url;
      this.method = request.method;
      this.body = request.body;
      this.tag = request.tag;
      this.headers = request.headers.newBuilder();
    }
public Request build() {
      if (url == null) throw new IllegalStateException("url == null");
      return new Request(this);
    }
```

## Call

```java
Call call = client.newCall(request);
```

Call对象的创建是**调用的OkHttpClient对象的newCall**方法，传入一个Request对象参数。至此我们的三个对象就关联起来了，接下来我们看一下OkHttpClient中的newCall方法。

```
@Override public Call newCall(Request request) {
    return RealCall.newRealCall(this, request, false /* for web socket */);
}
```

newCall方法的返回值类型是一个Call，需要的入参是一个Request对象。
这里调用了RealCall类中静态方法newRealCall()，newRealCall()的返回值类型是一个Call。接下来我们到RealCall类中看一看具体实现

## RealCall

```java
//Call接口的实现类
final class RealCall implements Call {
  //OkHttpClient对象
  final OkHttpClient client;
  final RetryAndFollowUpInterceptor retryAndFollowUpInterceptor;
  private EventListener eventListener;
  final Request originalRequest;
  final boolean forWebSocket;

  // Guarded by this.
  private boolean executed;
  
  //构造函数
  private RealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
    this.client = client;
    this.originalRequest = originalRequest;
    this.forWebSocket = forWebSocket;
    this.retryAndFollowUpInterceptor = new RetryAndFollowUpInterceptor(client, forWebSocket);
  }
  
  //静态方法，内部通过构造函数创建RealCall对象
  static RealCall newRealCall(OkHttpClient client, Request originalRequest, boolean forWebSocket) {
    // Safely publish the Call instance to the EventListener.
    RealCall call = new RealCall(client, originalRequest, forWebSocket);
    call.eventListener = client.eventListenerFactory().create(call);
    return call;
  }
}
```

OkhttpClient对象调用newCall(request)方法实际获得的是**Call接口的实现类RealCall的对象**。到这里我们的3个类的创建过程都清晰了。

## **RealCall.AsyncCall**

![](https://img-blog.csdn.net/20180820181419856?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29teXJvYmlu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

## OkhttpClient、Request和Call总结

* OkHttpClient Builder方式创建。
* Request Builder方式创建。
* Call是一个接口，实现类是RealCall，RealCall是通过OkHttpClient 对象调用。
  newCall()方法传入Request 对象，内部调用的RealCall的静态方法newRealCall()方法通过构造函数创建。

## 同步请求（RealCall.execute()）

同步请求实际就调用了RealCall的execute();

```
@Override public Response execute() throws IOException {
    synchronized (this) {
      if (executed) throw new IllegalStateException("Already Executed");
      executed = true;
    }
    captureCallStackTrace();
    eventListener.callStart(this);
    try {
      client.dispatcher().executed(this);
      Response result = getResponseWithInterceptorChain();
      if (result == null) throw new IOException("Canceled");
      return result;
    } catch (IOException e) {
      eventListener.callFailed(this, e);
      throw e;
    } finally {
      client.dispatcher().finished(this);
    }
  }
```

以上就是execute()方法的内部逻辑，我们将上面代码拆开分析，这里只分析主干线，第一个if判断

```
if (executed) throw new IllegalStateException("Already Executed");
      executed = true;
```

表示请求只能执行一次

```
try {
      client.dispatcher().executed(this);
      Response result = getResponseWithInterceptorChain();
      if (result == null) throw new IOException("Canceled");
      return result;
    }
```

代码也很简单，try的逻辑也很简单，主要的就是上面两行代码，这里分别执行了client.dispatcher().executed(this)方法和getResponseWithInterceptorChain()方法。

上文有提到**-**中的重要属性和方法，前面newCall()方法我们已经分析过了，剩下的就是重要成员变量**dispatcher**，而client.dispatcher()返回的就是Dispatcher类在OkHttpClient中的成员变量dispatcher。

**OkhttpClient**中的 **dispatcher()**方法

```
public Dispatcher dispatcher() {
    return dispatcher;
}
```

方法很简单，就是返回Dispatcher类的实例对象，到这里我们的同步请求就把逻辑引入到Dispatcher类中。

RealCall中不管是execute函数还是enqueue函数，**最终都是通过OkHttpClient的Dispatcher发起的。**

## Dispatcher

Dispatcher可以翻译为**分发器**，是OKHttp中非常重要的一个角色。它是OkHttpClient中的一个成员变量

```java
//最大并发请求数为64
private int maxRequests = 64;
//每个主机最大请求数为5
private int maxRequestsPerHost = 5;
private @Nullable Runnable idleCallback;

/** Executes calls. Created lazily. */
//线程池
private @Nullable ExecutorService executorService;

/** Ready async calls in the order they'll be run. */
//准备执行的异步请求队列
private final Deque<AsyncCall> readyAsyncCalls = new ArrayDeque<>();

/** Running asynchronous calls. Includes canceled calls that haven't finished yet. */
//正在执行的异步请求队列
private final Deque<AsyncCall> runningAsyncCalls = new ArrayDeque<>();

/** Running synchronous calls. Includes canceled calls that haven't finished yet. */
//正在执行的同步请求队列
private final Deque<RealCall> runningSyncCalls = new ArrayDeque<>();
```

它的主要作用是用来调配请求任务的，Dispatcher会根据情况**决定任务是被放到ready队列还是放到running队列**。同时，还会根据条件将**任务从ready队列调入running队列**。

接下来深入Dispathcer类，其中重要的成员变量和方法都在上面的图中体现了，可以看到**Dispathcer中有线程池对象**，**还有3个队列**，以及**同步请求和异步请求**在RealCall中出现的方法execute()和enqueue(Callback responseCallback)。