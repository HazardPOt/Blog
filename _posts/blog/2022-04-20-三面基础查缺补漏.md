---
layout:     post
title:     三面基础查缺补漏
description:     Project JOB
date:     2022-04-21
author:     POt
header-img:     img/post-bg-kuaidi.jpg
catalog: true
category: blog
tags:     
    -   
        -   

    -   




---

## 动态链接和静态链接的区别

**静态连接的过程就已经把要连接的内容已经连接到了生成的可执行文件中**，就算**你在去把静态库删除也不会影响可执行程序的执行；**而动态连接这个过程却没有把内容连接进去，而是**在执行的过程当中，再去找要连接的内容，生成的可执行文件中并无要连接的内容**，因此当你删除动态库时，可执行程序就不能运行。**动态连接生成的可执行文件要比静态连接生成的文件要小一些。**

## 套接字原理

服务器端：服务器运行在特定的计算机上，并且具有绑定到特定端口号的 socket 。 服务器只是在等待，**监听客户端的套接字是否发出连接请求。**

客户端：客户端知道**服务器运行的机器的主机名以及服务器正在侦听的端口号。 要建立连接请求**，客户端会**尝试与服务器的机器和端口上的服务器汇合**。客户端还**需要向服务器标识自身， 以便绑定到在此连接期间将使用的本地端口号。**这通常由系统分配。

一条Socket连接代表着本地Socket→本地端口→网络介质→远程端口→远程Socket的链路

## 指针和引用的区别

1. **引用必须被初始化**，但是**不分配存储空间**。指针不声明时初始化，在**初始化的时候需要分配存储空间**。
2. 引用**初始化后不能被改变**，指针可以**改变所指的对象**。
3. **不存在指向空值的引用，但是存在指向空值的指针**。

## 两个类相互包含会发生什么？（A类成员有B类类型变量， B类有A类）

类与类之间的关系有三种：
A is- a B [泛化](https://so.csdn.net/so/search?q=泛化&spm=1001.2101.3001.7020) （继承 实现）
A has-a B 包含 （组合 聚合 关联）
A use-a B 依赖 （依赖）

包含又分为：组合，聚合，关联。它们都属于整体和部分的关系，但是有以下区别：

| 组合                                 | 聚合                 | 关联     |
| ------------------------------------ | -------------------- | -------- |
| 不可分割，要出现都出现，要消亡都消亡 | 创建时有可能是分开的 | 可以分割 |

一个类的对象当作另一个类的属性。（组合 聚合 关联）

**道理很简单，等同于先有鸡还是有蛋，你A中创建了B，B马上执行，但是他执行的时候又创建了A，你不断创建我，我不断创建你，这是典型的死循环例子**

## View的类型都有什么

View的布局显示方式有下面几种：线性布局（Linear Layout）、相对布局（Relative Layout）、表格布局（Table Layout）、网格视图（Grid View）、标签布局（Tab Layout）、列表视图（List View）、绝对布局（AbsoluteLayout）

## Android的数据存储方式

* SharedPreferences存储数据
* 文件存储数据
* SQLite数据库存储数据
* ContentProvider存储数据
* 网络存储数据

## 内存存储方式有哪些？堆和栈的区别？

* 页式存储
* 段式存储
* 段页式存储

堆：new出来的对象，人为开辟，空间较大，速度较慢，不连续空间

栈：JVM虚拟机栈、本地方法栈，主要是存储一些基本数据类型，系统自动分配，空间小，连续空间

## 内存泄漏和溢出

**内存泄漏（memory leak）：**是指程序在申请内存后，**无法释放已申请的内存空间**，导致系统无法及时回收内存并且分配给其他进程使用。

**2、内存溢出 （out of memory）：**:指程序申请内存时，**没有足够的内存供申请者使用**，导致数据无法正常存储到内存中。

## 线程不安全指的是? 解决方式

无法满足原子性，有序性，可见性

用线程安全的数据结构进行存储

## handler的实现方式？为什么要用handler

Handler主要用于异步消息的处理： 有点类似辅助类，封装了消息投递、消息处理等接口。当发出一个消息之后，首先进入一个消息队列，发送消息的函数即刻返回，而另外一个部分在消息队列中逐一将消息取出，然后对消息进行处理，也就是发送消息和接收消息不是同步的处理。 这种机制通常用来处理相对耗时比较长的操作。

- **子线程不能更改主线程的UI**
- **一般来说，所有显示在界面上的控件，都是由主线程创建的**
- 每个主线程都有一个Handler,Handler运行在主线程里，它与了线程可以通过Message对象来传递数据

## RecyclerView缓存介绍，RecyclerView快速滑动优化(增大缓存容量)

## MVP与MVVM区别讲一下？

1. MVVM和MVP**都可以实现UI和业务逻辑处理的解耦**，**但MVP需要定义大量UI和Model的接口供Presenter调用，修改起来比较麻烦；**MVVM在面对修改时，一般情况下ViewModel不需要做太多的改动。
2. **MVVM中，UI和数据的交互是自动的，并不需要Presenter转发**
3. **MVVM有大量的功能是通过xml自动生成的代码实现的，出现问题时不利于调试**
4. 使用dataBinding会导致大量的内存消耗：
    （1）会产生多余的数组，存放view对象
    （2）针对每一个控件都会产生一个回调对象

## 门禁，扫二维码进出，整个系统如何设计？

## Android系统工作过程的理解

## Fragment状态的理解？他和Activity有啥区别？

* onAttach()

  作用:使Fragment与宿主Activity关联起来

  ```java
  public void onAttach(Activity activity) {
      super.onAttach(activity);
      Log.i("onAttach_Fragment");
  }
  ```

  此回调函数执行完毕，Activity已经传进来了， 获得activity的传递的值就可以进行与activity的通信， 当然也可以使用getActivity()，但前提是这个fragment已经和宿主的activity建立关联，并且没有脱离，他只调用一次。

* onCreate()

  作用：系统创建Fragment的时候调用此函数，**一般在此函数内实例化一些变量**。这些变量主要是:当你暂停或者停止时你想保持的数据，如果我们要为fragment启动一个后台线程，可以考虑将代码放于此处。参数是：Bundle savedInstance, 用于保存 Fragment 参数, Fragement 也可以 重写 onSaveInstanceState(BundleoutState) 方法, 保存Fragement状态;

* OnCreatView()

  作用:第一次使用的时候fragment会在这上面**画一个layout出来**， 为了可以画控件要返回一个 布局的view，也可以返回null。

  当系统用到fragment的时候fragment就要返回他的view，越快越好 ，所以尽量在这里不要做耗时操作，比如从数据库加载大量数据显示listview，
   当然线程还是可以的。给当前的fragment绘制ui布局，可以使用线程更新UI，说白了就是加载fragment的布局的。 这里一般都先判断是否为null。

* onActivityCreated()

  作用:**与Activity相关的UI交互操作**，初始化那些需要父Activity或者Fragment的UI已经被完全初始化才能初始化的元素。如果在onCreateView里面初始化空间会慢很多，比如listview等。

  注意:此回调函数是**在Activity中的onCreate方法执行完后才进行调用的**，即:当执行onActivityCreated()的时候activity的onCreate才刚刚完成。所以在onActivityCreated()调用之前 activity的onCreate可能还没有完成，所以不能在onCreateView()中进行与activity有交互的UI操作，UI交互操作要放在onActivityCreated()里面进行。

* onStart()

  和activity一致，启动Fragement 启动时回调,，此时Fragement可见。

* onResume()

  和activity一致  在activity中运行是可见的。激活, Fragement 进入前台, 可获取焦点时激活。

* onPause()

  和activity一致  其他的activity获得焦点，这个仍然可见第一次调用的时候，指的是 用户 离开这个fragment(并不是被销毁) 通常用于用户的提交(可能用户离开后不会回来了)。

* onStop()

  和activity一致， fragment不可见的， 可能情况：activity被stopped了或者fragment被移除但被加入到回退栈中，一个stopped的fragment仍然是活着的如果长时间不用也会被移除。
  9.onDestoryView()

作用:fragemnt销毁相关联的UI布局， 清除所有跟视图相关的资源。在Fragment中的布局被移除时调用。

## 泛型

泛型，就是允许在定义类，接口，方法的时候使用类型参数，这个参数可以在类型的声明，方法的调用，实例的创建的时候动态的指定。

集合，反射等等地方都使用到了泛型，**免去了强制类型转换的不安全性问题**，包括code阶段以及运行阶段。**泛型是给编译器看的，让编译器拦截源程序中的非法输入，编译完以后就会去掉类型信息，防止强制类型转换，保证程序的运行效率。**对于参数化的泛型类型，getClass方法的返回值和原始类型完全一样。

- ①.类型检查，它将运行时类型转换的ClassCastException通过泛型提前到编译时期。
- ②.避免类型强转。
- ③.泛型可以泛型算法，增加代码的复用性。

java中的泛型基本上是在编译器中实现，用于编译器执行类型检查和推断，**然后生成普通的非泛型字节码，这种技术成为擦除。**

## 反射

反射提供了一种**在运行的时候动态的获取已给对象的所有信息的方法**。对于反射机制，可以动态的调用其任意的属性和方法。反射机制的一些日常使用：编译器的智能提示等。java里面使用reflect 和 class 两个技术来实现反射机制。

## 你是如何理解AMS的？

**ActivityManagerService**

AMS的作用，其实我们大可从以下几点入手组件启动、进程切换、Crash异常入手

AMS是Android中**最核心的服务**，主要负责系统中**四大组件**的**启动、切换、调度及应用进程的管理和调度**等工作，其职责与操作系统中的进程管理和调度模块相类似，因此它在Android中非常重要。 AMS是碰到的第一块难啃的骨头，涉及的知识点较多。为了帮助读者更好地理解AMS，接下来将带小伙伴么按五条不同的线来分析它。

## adb在进行debug过程中断点如何实现代码终止，调试时如何实现点一下一步就继续执行的

## LRU实现详细追问，单[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)如何实现时间复杂度O(1)，不要求时间复杂度的话呢

## LFU

**LFU算法：least frequently used，最近最不经常使用算法**

对于每个条目，维护其**使用次数 cnt**、**最近使用时间 time**。

**cache容量为 n**，即最多存储n个条目。

那么当我需要插入新条目并且cache已经满了的时候，需要删除一个之前的条目。删除的策略是：***\*优先删除使用次数cnt最小的那个条目\****，因为它最近最不经常使用，所以删除它。**如果使用次数cnt最小值为min_cnt，这个min_cnt对应的条目\**有多个\****，那么在这些条目中**删除最近使用时间time最早的那个条目**（举个栗子：a资源和b资源都使用了两次，但a资源在5s的时候最后一次使用，b资源在7s的时候最后一次使用，那么删除a，因为b资源更晚被使用，所以b资源相比a资源来说，更有理由继续被使用，即时间局部性原理）。

类似lru算法的想法，利用**哈希表+链表**。

[链表](https://so.csdn.net/so/search?q=链表&spm=1001.2101.3001.7020)是负责按时间先后排序的。哈希表是负责O(1)时间查找key对应节点的。

## 多态、多态应用的场景、原理是啥（具体点）

指允许不同类的对象对同一消息做出响应，**即同一消息可以根据发送的对象的不同而采用多种不同的行为。**

**多态的三要素：1.继承。2.重写。3.父类引用指向子类对象**

```java
//BaseClass是SubClass的父类
BaseClass a = new BaseClass();
BaseClass b = new SubClass();
a.baseMethod()//变量a调用baseMethod()方法，实际上会调用BaseClass的baseMethod()方法,会打印111
b.baseMethod()//变量b调用baseMethod方法，实际上会调用SubClass的重写baseMethod()方法，会打印222
Class BaseClass {
  void baseMethod() {
    System.out.println("111");
  }
}
Class SubClass {
  void baseMethod() {
    System.out.println("222");
  }
}
输出结果：
111
222
```

##### [对于变量a而言](http://notfound9.github.io/interviewGuide/#/docs/JavaBasic?id=对于变量a而言)

a的**编译类型是BaseClass**，**实际类型也是BaseClass**，所以调用baseMethod()会执行BaseClass#baseMethod()方法，打印出111。

##### [对于变量b而言](http://notfound9.github.io/interviewGuide/#/docs/JavaBasic?id=对于变量b而言)

b的的**编译类型是BaseClass**，但是实际赋值时，给变量b赋值的是SubClass对象，所以b的**实际类型是SubClass**。而SubClass重写了父类BaseClass#baseMethod()方法，所以调用baseMethod()方法会调用SubClass#baseMethod()，从而打印出222。

a和b的编译类型相同，却展现出了不同的行为特征，这就是多态。

## 三次握手的第三次失败了会怎么样

## String a=new String("abc")使用了几块内存空间

String是一个特殊的包装类数据。可以用：
String str = new String("abc");
String str = "abc";
两种的形式来创建，**第一种是用new()来新建对象的，它会在存放于堆中。每调用一次就会创建一个新的对象。**
而第二种是先在方法区常量池中**创建一个对String类的对象引用变量str，然后查找常量池中有没有存放"abc"，如果没有，则将"abc"存放进常量池，并令str指向”abc”，如果已经有”abc” 则直接令str指向“abc”。**

## context-type有哪些

## 线程池 用到的设计模式？

### 策略模式

在新创建一个线程池的时候，会在构造方法传入一个拒绝的策略，jdk内部封装了几个常用的拒绝策略，并抽象了拒绝策略的接口，供开发者去实现。

| 拒绝类              | 拒绝实现           | 位置   |
| :------------------ | :----------------- | :----- |
| AbortPolicy         | 抛出异常           | 2047行 |
| DiscardPolicy       | 不去处理           | 2071行 |
| DiscardOldestPolicy | 执行任务           | 2107行 |
| CallerRunsPolicy    | 同步执行(main线程) | 2023行 |

## 有没有遇到过 HashMap 线程安全问题？它为什么多线程不安全？多线程扩容的时候死循环遇到过吗？

resize的时候会不安全

* **put的时候导致的多线程数据不一致。**
* **HashMap的get操作可能因为resize而引起死循环**

HashMap是采用链表解决Hash冲突，因为是链表结构，那么就很容易形成闭合的链路，这样在循环的时候只要有线程对这个HashMap进行get操作就会产生死循环。

在单线程情况下，只有一个线程对HashMap的数据结构进行操作，是不可能产生闭合的回路的。

那就只有在多线程并发的情况下才会出现这种情况，那就是在put操作的时候，如果size>initialCapacity*loadFactor，那么这时候HashMap就会进行rehash操作，随之HashMap的结构就会发生翻天覆地的变化。**很有可能就是在两个线程在这个时候同时触发了rehash操作，产生了闭合的回路。**

## 协程用过吗？

## 如何决定哪些逻辑放在onCreate()，哪些放在onStart()？onResume()又有什么作用吗？

OnCreate()在第一次创建活动时调用。这是您应该完成所有**常规静态设置的位置**：创建视图，将数据绑定到列表等。**setContentView()、findViewById() 要在 onCreate() 中被调用**

onStart()：当我们需要在活动的可见生命周期中**使用系统资源时，应该在OnStart中注册**。

## 安卓应用的优先级，系统怎么判定？

## 常见的安卓布局

## handler对Activity是哪种引用类型，handler如何通过这种引用去引用Activity

WeekReference，当用户退出activity时就只剩下handler还存在activity的引用了，这时候碰到GC时需要将handler中的引用回收，只有弱引用达到要求，软引用可能需要等待到内存不足时才能回收。

## 多进程多线程的优势和劣势

多线程：

* 线程间通信会更加灵活
* 线程的创建和销毁成本比较低
* 线程间的切换调度成本更加低

多进程

* **稳定,健壮性高**

## 死锁四个基本特征

## synchronize(Object o)与synchronize放在函数签名里的区别是什么，一个是显式锁一个是隐式锁

## java其他的锁有了解吗？

## 工厂模式是怎样的呢？

## 面向对象的三大特性

继承、封装、多态

## 进程之间也能发生死锁吗？

## epoll为什么更加高效

共享内存，每次调用时不用从用户空间拷贝到内核空间了

## Binder是做什么的？IPC是什么？

Binder**，一个通过内存映射实现跨进程通信的东东**，Android中一个进程空间分为用户空间和内核空间，其中用户空间数据不可共享，内核空间数据可共享。
因此跨进程通信需要内核空间的支持，传统IPC通信例如管道，Socket等，它们是内核空间的一部分，可以直接拷贝，通过内容提供者进程copy_from_user()拷贝到内核空间，再通过copy_to_user()复制给内容接收方用户空间，实现的进程间通信。

## hash冲突的解决方法，拉链法[链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)过长问题怎么优化

## 堆的碎片问题

标记整理算法

## 怎么管理堆

## 多线程的资源竞争问题的解决方法

* **临界区，通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。**
* **互斥量，为协调共同对一个共享资源的单独访问而设计的。**
* **信号量，为控制一个具有有限数量用户资源而设计。**
* **事件：用来通知线程有一些事件已发生，从而启动后继任务的开始。**
* **读写锁，这种锁允许在有其他程序正在写的情况下读取资源，所以如果资源允许脏读，用这个比较合适**
* **原子锁，通过原子操作Interlocked.CompareExchange实现“无锁”竞争**

## 有哪些锁机制

## 互斥锁和自旋锁的区别

- **互斥锁（muteX）**加锁失败后，线程释放CPU，给其他线程；
- **自旋锁（Spin Lock）**加锁失败后，线程会忙等待，直到它拿到锁；

## 讲一下事件冲突

## 数据库有了解吗? 索引了解吗? 怎么实现的快速查找? 快速查找的是什么东西?

## 线程同步有哪些方式

* Object类中的wait和notify

## TCP三次握手、四次挥手过程说一下。

### 为什么三次握手，不能两次



## 64匹马，8条赛道，选出前四名至少需要比赛多少轮？

分八组，八组先跑，得到每组前一名；每组第一名再进行比赛，得出最快的直接晋级；因为只取前四名，所以只留下A1 - A4, B1 - B3, C1 - C2, D1；A1直接晋级，D1待定，剩下的八匹再比；观察C1看是否加赛

## **只有两个无刻度的水桶，一个可以装6L水，一个可以装5L水，如何在桶里装入3L的水?**

1. 先将5L的桶装满，将5L的桶的水倒入6L的桶中。这时5L的桶是空的，6L的桶中有5L的水
2. 再将5L的桶装满，倒入6L的桶中。这时5L的桶有4L的水，6L的桶是满的
3. 将6L的桶中的水倒掉，5L的桶的水倒入6L的桶中。这时5L的桶是空的，6L的桶中有4L的水
4. 将5L的桶装满，倒入6L的桶中。这时5L的桶还有3L的水，6L的桶是满的。

## **1000瓶药水里面只有1瓶是有毒的，毒发时间为24个小时，问需要多少只老鼠才能在24小时后试出那瓶有毒。**

log2N，和二进制有关，老鼠1中毒，老鼠2未中毒，老鼠3中毒。那么三只老鼠的二进制表示为101，即5号药水有毒。因为老鼠1中毒，说明4、5、6、7号药水中含有毒的药水。老鼠2未中毒，说明2、3、6、7无毒。老鼠3中毒，说明1、3、5、7中有一瓶有毒。所以有毒的为5号药水，其实和直接将二进制转化为十进制的结果是一样的。

## **家里有两个孩子，一个是女孩，另一个也是女孩的概率是多少？**

男女 女女 女男 ~~男男~~，其中男男被排除了，还剩 1 / 3

## **烧一根不均匀的绳，从头烧到尾总共需要1个小时。现在有若干条材质相同的绳子，问如何用烧绳的方法来计时一个小时十五分钟呢?**

将绳子１从一段开始烧，同时将绳子２从两端烧，绳子２在半小时后烧完。

这时开始计时，将绳子１的另一端点燃，从计时开始绳子１烧完后是15分钟，然后点燃绳子3的一端，绳子3烧完需要一个小时。加上刚才的15分钟正好是1小时15分钟。