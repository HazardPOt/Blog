---
layout:     post
title:     计算机网络（第二轮 2022.04.10 更新）
description:     Project JOB
date:     2022-03-25
author:     POt
header-img:     img/post-bg-kuaidi.jpg
catalog: true
category: blog
tags:     
    -   
        -   

    -   

---

## 协议栈

### OSI协议参考模型

**7层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层**（物联网淑慧试用）

- 应用层：应用层协议定义的是应用进程间的通信和交互的规则，不同的网络应用需要不同的应用层协议
- 表示层：把数据转换为能与接收者的系统格式兼容并适合传输的格式
- 会话层：在数据传输中设置和维护电脑网络中两台电脑之间的通信连接
- 传输层：向两台主机进程之间的通信提供**通用的**数据传输服务
- 网络层：基于网络层地址（IP地址）进行不同网络系统间的路径选择
- 数据链路层：在不可靠的物理介质上提供可靠的传输
- 物理层：在局域网上透明地传送比特，尽可能屏蔽掉具体传输介质和物理设备的差异

### TCP/IP协议参考模型

五层：网络接入层、网络层、传输层、应用层（网网输用）

- 应用层：对应于 OSI 参考模型的应用层，为用户提供所需要的各种服务。定义的是应用进程间的通信和交互的规则，不同的网络应用需要不同的应用层协议。协议包括 SMTP、HTTP、FTP 等
- 传输层：对应于 OSI 参考模型的传输层，为应用层实体提供端到端的、**通用的**通信功能，保证了数据包的顺序传送及数据的完整性。“通用的”是指不同的应用可以使用同一个运输层服务。协议包括 TCP、UDP 等
- 网络层（或网际互联层）：对应于 OSI 参考模型的网络层，主要解决主机到主机的路由问题。协议包括 IP、ICMP 等
- 网络接入层：对应于 OSI 参考模型的物理层和数据链路层，负责相邻的物理节点间的可靠数据传输。协议包括 ARP、IEEE 802.2 等

### TCP/IP参考模型各层协议

![](https://s2.loli.net/2022/03/24/LjAHPuvI7nD4oBt.png)

### 比较TCP/IP参考模型和OSI参考模型

共同点：

- 都采用了层次结构的概念
- 都能够提供面向连接和无连接的通信服务机制

不同点：

- OSI 采用了七层模型，而 TCP/IP 是四层
- OSI 是一个在协议开发前设计的、有清晰概念的模型；TCP/IP 是先有协议集然后建立的、事实上得到广泛应用的弱模型，功能描述和实现细节混在一起
- OSI 的网络层既提供面向连接的服务，又提供无连接的服务；TCP/IP 的网络层只提供无连接的网络服务
- OSI 的传输层只提供面向连接的服务；TCP/IP 的传输层即提供面向连接的服务 TCP，也提供无连接的服务 UDP

## 集线器、网桥、交换机、路由器

* 网线是物理层的硬件

- 集线器（Hub）是**物理层**的硬件，连接所有的线路，广播所有信息
- 网桥（Bridge）是**数据链路层**的硬件。网桥隔离两个端口，不同的端口形成单独的冲突域，减少网内冲突。网桥在不同或相同类型的 LAN 之间存储并转发数据帧，根据 MAC 头部来决定转发端口，显然是数据链路层的设备
- 交换机（Switch）是**数据链路层**的硬件，相当于多端口的网桥。交换机内部存储 MAC 表，只会将数据帧发送到指定的目的地址
- 路由器（Router）是**网络层**的硬件，根据 IP 地址进行寻址，不同子网间的数据传输隔离

### 每一层常见的协议与作用

### 比特、帧、数据包、数据段、报文

PDU：Prtocol data unit，协议数据单元，指对等层协议之间交换的信息单元。PDU 再往上就是数据（data）。

在 OSI 模型里，PDU 和底下四层相关：

- 物理层———**比特（Bit）**
- 数据链路层———**帧（Frame）**
- 网络层———**分组、数据包（Packet）**
- 传输层———**数据段（Segment）**

第五层或以上为**数据（data）**。也有一种说法是，应用层的信息称为**消息、报文（message）**，表示完整的信息。

## RTT TTL MSL

### RTT

RTT——Round Trip Time，客户到服务器往返所花时间，也就是**一个数据包从发出去到回来的时间**

### MSL

MSL——Maximum Segment Lifetime，中文可以译为“**报文最大生存时间**”，超过这一时间报文就会被丢弃

### TTL

TTL——Time To Live的缩写，中文可以译为“**生存时间**”，这个生存时间是由源主机设置初始值但不是存的具体时间，而是存储了一个ip数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0则数据报将被丢弃

## TCP流量控制

### TCP流量控制机制

#### 窗口

![](https://coolshell.cn/wp-content/uploads/2014/05/sliding_window-900x358.jpg)

上图中，我们可以看到：

- 接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。

- 发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。

于是：

- 接收端在给发送端回ACK中会汇报自己的**AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;**（滑动窗口大小 = 缓冲区最大容量 - 收到的包的最后一个位置）

- 而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。

#### 滑动窗口原理

AB两台主机之间要互相发送数据，A向B发送，B向A进行流量控制。

滑动窗口大小由接收方决定，接收方将滑动窗口大小放入TCP报文的窗口**缓冲区**中。

发送方收到确认报文后，根据报文动态调整滑动窗口大小

#### 零窗口

**如果接收端处理过慢，则将窗口值置位0，则进入零窗口**

零窗口时双方均不发送消息，发送方启动一个计时器，计时器超时后向接收方发送1字节的探测报文，查询当前窗口大小。若窗口为0，则继续等待，不为0，则窗口大小，继续接受数据。

#### Nagle算法

如果接收端处理过慢，每次窗口只能接收几个字节，**那么当发送端每次都发送这几个字节时，会有大量带宽浪费在TCP/IP的首部上**，因此Nagle提出了Nagle算法。**Nagle算法的工作方式是【缓存 / 累计】要发送的小数据，直到滑动窗口值大于MSS（max Segment Size，TCP报文段一次可传输的最大分段大小）时再一并发送**

### TCP拥塞控制机制

#### 慢启动

拥塞窗口值以指数大小增长，直到大于等于门限值时慢启动结束

#### 拥塞避免

到达门限值时，拥塞窗口大小以+1+1的形式增加，直到网络阻塞

#### 超时重传

当网络发生阻塞时，将门限值大小置为当前拥塞窗口的一半，拥塞窗口置为0，从慢启动开始

#### 快速重传 / 快速恢复

快重传：接收端收到乱序包时，会发送`duplicate ACK`通知发送端，当发送端收到三个ACK时，就会立即开始重传未到达的数据包

快恢复：门限值降为拥塞窗口的一半，拥塞窗口降为拥塞窗口的一半，并进行拥塞避免算法。

（为什么可以执行拥塞避免算法呢？因为已经进行完快重传算法，说明网络此时是通畅的）

## TCP的三次握手和四次握手

### TCP标志位

1. **SYN**（synchronous）： **发送/同步标志，用来建立连接**，和 ACK 标志位搭配使用。A 请求与 B 建立连接时，SYN=1，ACK=0；B 确认与 A 建立连接时，SYN=1，ACK=1
2. **ACK**（acknowledgement）：**确认标志**，表示确认收到请求
3. PSH（push） ：**表示推送操作**，就是指数据包到达接收端以后，不对其进行队列处理，而是尽可能的将数据交给应用程序处理
4. **FIN**（finish）：**结束标志**，表示关闭一个 TCP 连接
5. RST（reset）：**重置复位标志**，用于复位对应的 TCP 连接
6. URG（urgent）：**紧急标志**，用于保证 TCP 连接不被中断，并且督促中间层设备尽快处理

### 三次握手、四次握手过程

![](https://imageslr.com/media/15942212152079.jpg)

三次握手：

1. Client将SYN置1，生成SequenceNumber发送给Server
2. Server收到后将SYN置为1，ACK置为1，将AcknowledgeNumber = SequenceNumber + 1发送给Client
3. Client接受后将ACK置为1，验证AcknowledgeNumber = SequenceNumber +  1，验证通过后连接成立

四次挥手：

![](https://imageslr.com/media/15942266727771.jpg)

1. Client将FIN置为1，生成SequenceNumber发送给Server
2. Server收到后将ACK置为1，将AcknowledgeNumber =SequenceNumber + 1发送给Client
3. 待全部数据传输完成后将FIN置为1，发送SequenceNumber给Client
4. Client收到后将ACK置为1，验证AcknowledgeNumber = SequenceNumber + 1，并将AcknowledgeNumber = SequenceNumber + 1 发送给Server端。此时Client端等待两个MSL后关闭，Server端验证AcknowledgeNumber = SequenceNumber + 1后自行关闭

### 握手阶段、传输阶段、挥手阶段的序列号与确认号

序列号（Sequence Number），确认号（Acknowledge Number）

#### 序列号（Sequence Number）

- 在 SYN flag 置 1 时，表示当前连接的初始序列号（Initial Sequence Number，ISN）
- 在 SYN flag 置 0 时，表示当前报文段中的第一个字节的序列号

序列号的规则：

- 握手阶段，`[SYN]` 包即使没有传送数据，也会消耗一个序列号。因此，建立连接后的序列号从 `ISN+1` 开始
- 挥手阶段，`[FIN/ACK]` 包即使没有传送数据，也会消耗掉一个序列号
- 数据传输阶段，序列号 = 第一个报文段的序列号 + 已经发送的字节数
  - 比如第一个报文段的序列号为 `S`，已经发送了 100 个字节，则下一个报文段的序列号为 `S+100`
  - 如果某个报文段不携带数据，不会消耗序列号，下一个报文段还是用相同的序列号发送
  - 正常情况下，B 给 A 的确认号，就是 A 下一个报文段的序列号
- 客户端三次握手第三步的 `[ACK]` 包，和传输阶段的第一个报文段，有相同的序列号

#### 确认号 Acknowledge Number

- ACK flag 置 1 时才有效，表示接收方期待的下一个报文段的序列号。一般是上次收到的报文段 seq + 1

### 为什么需要三次握手，而不是两次或四次

### 为什么不是两次？

1. 容易建立无效连接，浪费Server资源。举个例子，Client向Server发送SYN和Squence Number请求连接，但由于网络阻塞，报文没有到达Server，Client端计时器超时后重新发送报文请求连接，此时Server端收到报文，连接建立；过了一会儿，Server端又收到了第一次发送的已经在Client端被丢弃的报文，若只进行两次连接，那么Server端就会也对被丢弃的报文建立连接，导致Server端资源浪费。
2. Client端无法确认Server收到报文，连接已经建立。

### 为什么不是四次？

可以是四次，将第二次握手分开，第一次传输ACK，第二次传输Acknowledge Number，但是这样会浪费服务器资源，三次连接是最小次数的连接。

### 为什么需要四次握手，而不是三次

因为 **TCP 是全双工的**，如果是三次连接，那么将会是FIN_Wait2和Close_Wait合并，存在Close_Wait的意义就是等待数据传输完成后，在将FIN置为1，否则会存在数据传输不完整就关闭连接的情况。

### 为什么客户端TIME_WAIT需要等待2MSL

MSL（Max Segment Length）报文的最长存活时间

1. 为了等待服务器倘若没有收到ACK，TIME_WAIT会重新发送ACK直至收到

2. 防止已失效的连接请求报文段出现在之后的连接中。

   TCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。

### TIME_LIMIT是哪一方会进入的状态？

**`TIME_WAIT` 是主动断开连接的一方会进入的状态。**

`TIME_WAIT` 需要等待 2MSL，在大量短连接的情况下，`TIME_WAIT` 会太多，这也会消耗很多系统资源。对于服务器来说，在 HTTP 协议里指定 KeepAlive（浏览器重用一个 TCP 连接来处理多个 HTTP 请求），由浏览器来主动断开连接，可以一定程度上减少服务器的这个问题。

### SYN攻击的原理

一直发送SYN但不回应，导致ServerSYN队列一直占用此资源，直到Server端SYN队列被占满

## TCP 协议（其他）

### TCP 为什么是面向连接的？

- 发送之前需要先建立连接（三次握手）
- **使用排序和确认机制（分组之间并不是独立的；记录了分组之间的状态信息）**
- 具有流量控制与拥塞控制
- 发送完毕后要释放连接（四次挥手）

### TCP 如何保证传输的可靠性？

1. **序列号：解决乱序问题**
2. **确认号 / 超时重传机制：解决丢包问题**

### TCP / UDP 协议头，每个字段的作用？

UDP 协议头包含 4 个字段：源端口、目的端口、长度和校验码，其中每一个字段都占 2 字节，总长度 8 字节

TCP协议头20个字节

## TCP、UDP对比

### 二者对比

1. TCP面向连接诶，UDP无连接
2. TCP可靠传输、UDP不可靠传输
3. TCP一对一连接，UDP一对一、一对多、多对一、多对多连接
4. TCP是面向字节流传输的，UDP是面向报文的（面向字节流：TCP 将要发送的数据视为无结构的字节流，**如果发送的数据太长，就拆分发送，如果发送的数据太短，则积累较多的字节后再发送**；面向报文：UDP **一次发送一个报文，不管多大**，都以报文为发送单位）
5. TCP有拥塞控制，UDP无拥塞控制
6. TCP协议头20个字节，UDP协议头8个字节
7. UDP无需维护连接状态表

### 应用场景

TCP用于可靠传输的场景，比如HTTP连接、FTP连接等

UDP用于对时延要求高的场景，如游戏、直播、流媒体等

### 面向字节流、面向报文的含义

- **面向字节流：TCP 将要发送的数据视为无结构的字节流，如果发送的数据太长，就拆分发送，如果发送的数据太短，则积累较多的字节后再发送**
- **面向报文：UDP 一次发送一个报文，不管多大，都以报文为发送单位**

## HTTP原理

### HTTP 请求方法、GET 和 POST 的区别？

GET：向Server请求资源

POST：可能会修改服务器的资源（提交表单）

### HTTP 状态码

#### 成功响应（200–299）

* 200：200 OK 确认
* **201：Created 请求已经成功，并因此创建了一个新的资源，在POST后返回的相应。**
* **204：No Content：该请求已成功处理，但是返回的相应报文不包含实体部分**
* 206：Partial Content **在客户端表明自己只需要目标URL上的部分资源的时候返回的.这种情况经常发生在客户端继续请求一个未完成的下载的时候**(通常是当客户端加载一个体积较大的嵌入文件,比如视屏或PDF文件),或者是客户端尝试实现带宽遏流的时候.

#### 重定向（300–399）

* 301：永久重定向
* 302：暂时重定向
* **304 Not Modified**：如果客户端发送了一个**带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变**，则服务器应当返回这个状态码。304 响应不包含消息体

#### 客户端错误（400-499）

* **400 Bad Request 语法有误**
* **401 Unauthorized 需要认证**
* 403 Forbidden 禁止访问
* 404 Not Found 服务器找不到该资源

#### 服务器错误 （500–599）

- 500 Internal Server Error：服务器遇到了不知道如何处理的情况
- 502 Bad Gateway：网关错误，作为网关或代理角色的服务器，从上游服务器（如tomcat、php-fpm）中接收到的响应是无效的
- 503 Service Unavailable：服务器无法处理请求，常见原因是服务器因维护或重载而停机

### 301/302 重定向原理

返回的 Header 中有一个 `Location` 字段指向目标 URL，浏览器会重定向到这个 URL。

### 304 缓存原理，不同缓存头的区别

### HTTP/1.1、2.0 引入的变化

### HTTP/2.0 关键特性：压缩首部、服务端推送、多路复用

### HTTP 请求报文、响应报文的格式

### Cookie 和 Session 的区别

Cookie认证机制就是为一次请求认证在服务端创建一个Session对象，同时在客户端的浏览器端创建了一个Cookie对象；通过客户端带上来Cookie对象来与服务器端的session对象匹配来实现状态管理的。默认的，当我们关闭浏览器的时候，cookie会被删除。但可以通过修改cookie 的expire time使cookie在一定时间内有效；

#### Cookie

Cookie是Client端保存状态的数据结构，Session是客户端保存状态的数据结构。

Cookie怎么来的呢，就是比如说我要登录，我向服务器发送一个表单进行登录，服务器返回我一个登录成功的状态还有一个Cookie，为什么要有Coolkie呢，因为Http是无状态连接的，也就是说不会保存状态，这样用Cookie来保存状态，**存在浏览器里，可以设置过期时间**，每次与服务器连接时，在表头都会带着Cookie，服务器通过查表就可以得知状态了。**如果浏览器禁用了 cookie，可以使用 URL 重写机制，将信息保存在 URL 里**

#### Session

- 存在服务端，由服务器维护，一段时间后 session 就失效了
- **本质上，session 还是通过 cookie 实现的**。浏览器的 cookie 中只保存一个 `sessionId`，所有其他信息均保存在服务端，由 `sessionId` 标识
- Session 失效，其实是服务器设置了失效时间。如果用户长时间不和服务器交互（比如 30 分钟），那么 session 就会被销毁；交互的话，就会刷新 session

### GET POST 报文

#### GET

```
GET /books/?sex=man&name=Professional HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.7.6)
Gecko/20050225 Firefox/1.0.1
Connection: Keep-Alive
```

#### POST

```
 POST http://www.example.com HTTP/1.1
  Content-Type: application/x-www-form-urlencoded;charset=utf-8
    
  title=test&name=hello
```



```
 POST http://www.example.com HTTP/1.1 
  Content-Type: application/json;charset=utf-8
    
  {"title":"test","name":"hello"}
```

### HTTP 分块传输编码

在 HTTP 通信过程中，请求的编码实体资源尚未全部传输完成之前，浏览器无法显示请求页面。在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。

分块传输编码会将实体主体分成多个部分（块），每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用 `0(CR+LF)` 来标记。

使用分块传输编码的实体主体会由接收的客户端负责解码，恢复到编码前的实体主体。

### Header 中 Content-Type / Content-Length / Content-Encoding 等字段的含义

### [进阶] 断点续传原理 [TODO]

### [进阶] QUIC、HTTP 3.0

## HTTP的缓存机制

#### 强制缓存、协商缓存的原理，两者对比

#### 判断缓存失效的依据（Expires、Last-Modified、ETag 等）

#### 与缓存相关的 HTTP 状态码

#### 与缓存相关的 HTTP 消息头

#### 用户行为与缓存是否刷新的关系

#### 缓存策略的选择思路

## DNS原理

### DNS 的解析过程

1. 浏览器自身查询DNS缓存
2. 查询操作系统host文件
3. 查询LDNS
4. LDNS查询根服务器，根服务器返回查询域主域名服务器地址
5. 查询子服务器，若无则返回下一层服务器的地址（.com -> baidu.com -> www.baidu.com -> zhidao.baidu.com）
6. 重复5，直到查询到IP地址
7. LDNS拷贝一份到自己的缓存，然后返回给本机

### DNS 记录格式

| Header     | 消息头部                                 |
| ---------- | ---------------------------------------- |
| Question   | DNS请求                                  |
| Answer     | 回答请求的资源记录（Resource Record(s)） |
| Authority  | 指向域的资源记录                         |
| Additional | 其他资源记录                             |

### DNS 劫持原理与防范 

### 主流的公有云的 DNS 服务端架构

## IP 原理

### IP 号分类规则

![](https://github.com/wolverinn/Waking-Up/raw/master/_v_images/20191201085151639_2895.png)

![](https://img-blog.csdnimg.cn/20181202232119473.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNTU3Nw==,size_16,color_FFFFFF,t_70)

### 如何划分子网

从主机号host-id借用若干个比特作为子网号subnet-id；子网掩码：网络号和子网号都为1，主机号为0；数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网：将子网掩码与目标地址逐比特与操作，若结果为某个子网的网络地址，则送到该子网。

### IP 分组转发规则

### 什么是 NAT 协议

用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。

### 什么是 ARP 协议

**ARP协议完成了IP地址与物理地址的映射**。每一个主机都设有一个 ARP 高速缓存，里面有**所在的局域网**上的**各主机和路由器的 IP 地址到硬件地址的映射表**。当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这个MAC地址，如果没有，就**向所在的局域网发起一个ARP请求的广播包**（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，**如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。**源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。（**人话：将IP地址和MAC地址联系起来**）

### 集线器、网桥、交换机、路由器位于哪一层

- 集线器（Hub）是**物理层**的硬件，连接所有的线路，广播所有信息
- 网桥（Bridge）是**数据链路层**的硬件。网桥隔离两个端口，不同的端口形成单独的冲突域，减少网内冲突。网桥在不同或相同类型的 LAN 之间存储并转发数据帧，根据 MAC 头部来决定转发端口，显然是数据链路层的设备
- 交换机（Switch）是**数据链路层**的硬件，相当于多端口的网桥。交换机内部存储 MAC 表，只会将数据帧发送到指定的目的地址
- 路由器（Router）是**网络层**的硬件，根据 IP 地址进行寻址，不同子网间的数据传输隔离

### 为什么局域网的 IP 普遍是 192.168 开头

![](https://img-blog.csdnimg.cn/2018120308340421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzYyNTU3Nw==,size_16,color_FFFFFF,t_70)

所以局域网在**选取使用私有地址**时，一般会按照实际需要容纳的主机数来选择私有地址段。**常见的局域网由于容量小，一般选择C类的192.168.0.0作为地址段使用**，一些大型企业就需要使用B类甚至A类地址段作为内部网络的地址段。

### IPv6 的基本概念 / 为什么引入 IPv6

**32位的IPv4地址已经耗竭，IPv6采用128位的地址长度拥有更大的地址空间**

## Token

![](https://img-blog.csdnimg.cn/img_convert/32747f649dfaae1ed4ad8c6c42a9bc49.png)

使用基于 Token 的身份验证方法，在**服务端不需要存储用户的登录记录**。

 1、客户端使用用户名跟密码请求登录

2、服务端收到请求，去验证用户名与密码

3、验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端

4、客户端收到 Token 以后可以把它存储起来，比如放**在 Cookie 里或者 Local Storage** 里

5、客户端**每次向服务端请求资源的时候需要带着服务端签发的 Token**

6、服务端收到请求，然后去**验证客户端请求里面带着的 Token**，如果验证成功，就向客户端返回请求的数据

三部分 Base64编码

## IP寻址

A 要发送数据给 B，就可以封装网络层数据包 `src-ip 192.168.0.101，dest-ip 192.168.1.101`

网络层要传递给链路层，就需要知道双方的 mac 地址。根据路由表得知， src 和 dest 不在同一个网段，只能将数据交给网关（下一跳） 192.168.0.1 ，所以广播一个 arp request 询问 192.168.0.1 的 mac 地址

ROUTE 收到 arp request 后，广播一个 arp reply

A 收到 arp reply，就可以封装数据帧 `src-mac aaaa,dest-mac cccc`，然后将数据传出去

ROUTE 收到数据包，根据路由表知道 192.168.1.101 是自己的`直连网段`，就发出 arp 请求，查找其 mac 地址。

B 收到 arp request 后，广播 arp reply。

ROUTE 收到 B 的arp reply， 就修改数据包的 src-mac 和 dest-mac为 `src-mac:cccc，dest-mac:bbbb`

B 收到该数据包，完结。

## 浏览器输入url后经历的过程

1. 首先，在浏览器地址栏中输入url

2. 浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。

3. 在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。

4. 浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。

5. 握手成功后，浏览器向服务器发送http请求，请求数据包。

6. 服务器处理收到的请求，将数据返回至浏览器

7. 浏览器收到HTTP响应

8. 读取页面内容，浏览器渲染，解析html源码

9. 生成Dom树、解析css样式、js交互

10. 客户端和服务器交互
11. ajax查询
