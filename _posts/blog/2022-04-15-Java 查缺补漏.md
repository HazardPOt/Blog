---
layout:     post
title:     基础知识查缺补漏
description:     Project JOB
date:     2022-04-18
author:     POt
header-img:     img/post-bg-kuaidi.jpg
catalog: true
category: blog
tags:     
    -   
        -   

    -   

---

## Exception和Error的区别

两者都是Throwable的子类，按照Java源码当中注释的说明，两者的区别在于

* Error表示的是程序不应该尝试去捕捉的问题，大多数表示程序的非运行问题，这类问题很难用程序来处理，因此需要重新启动程序
* 而Exception表示合理的程序可能去尝试捕捉的问题，主要分受检查(checked)和不受检查(unchecked)
  * 大多数Exception都是受检查的，受检查的Exception在代码中必须进行捕获处理
  * RuntimeException（**运行时异常：空指针，越界……**）和它的子类是不受检查的

## String能被继承吗？

不能，因为String是final类型的

## Java基本数据类型

| 基本类型 | 位数(bit) | 字节(byte) | 默认值  |
| -------- | --------- | ---------- | ------- |
| int      | 32        | 4          | 0       |
| short    | 16        | 2          | 0       |
| long     | 64        | 8          | 0L      |
| byte     | 8         | 1          | 0       |
| char     | 16        | 2          | 'u0000' |
| float    | 32        | 4          | 0f      |
| double   | 64        | 8          | 0d      |
| boolean  | 1         | -          | false   |

* 1个字节的：byte
* 2个字节的：char，short
* 4个字节的：int，float
* 8个字节的：long，double

## 浅拷贝和深拷贝的区别

* 深拷贝：new一个新的对象，拷贝的是对象的内容（Arrays.copyOfRange）
* 浅拷贝：拷贝的是对象的引用

## 什么是多态，多态有什么好处

多态指的是**同一个接口给根据不同对象进行不同的的操作**，直接体现是父类的引用可以指向子类的对象，或者是接口的引用可以指向实现类的对象

* 多态的好处：降低耦合度，使操作可以接口化，提高可扩展性

## Arrays.sort 原理

* 判断数组长度，如果排序的数组长度小于阈值，那么就用快排
* 之后评估乱序程度，用run数组记录每个单调子数组的开始下标，用count记录单调组数组的个数
  * 如果乱序程度较高，就用快排
  * 如果乱序程度低，就用归并排序

## 为什么重写equals()必须重写hashCode()

因为java要求，**相同的对象必须返回相同的hashcode**

* 如果重写了equals()而不重写hashCode()，可能会导致相同的对象返回不同的hashcode，从而导致集合中出现相同的元素
* 如果重写了hashCode()而不重写equals()，equals默认判断地址是否相等，如果两个相等的hashCode存在不同的两个地址中，那么也会插入相同的对象。

## String StringBuilder和StringBuffer的区别

* String是不可修改的，StringBuilder和StringBuffer是可修改的
* StringBuffer线程安全（方法被Synchronized修饰），StringBuilder线程不安全
* StringBuffer效率较低，StringBuilder效率比较高

## BIO NIO AIO的区别

* BIO是同步阻塞I/O，应用程序read之后就一直阻塞，直到内核将数据拷贝到用户空间
* NIO同步非阻塞IO，是指反复调用read进行轮询，这个期间是不阻塞的，而直到内核将数据拷贝到用户空间之后，再用read读取数据，读取期间线程仍然是阻塞的。
* AIO是异步的IO，read后立即返回，不会阻塞

## 代码块分别于什么时候执行？

* 静态代码块在JVM加载类的的时候就执行了
* 构造代码块是在构造对象时进行，且**执行时间早于构造方法**

## static关键字的作用

* 修饰变量和方法，表示这个变量/方法属于这个类，且不属于单个对象

* 修饰代码块，表示这个代码块为静态代码块

* 修饰内部类，表示该类为静态内部类，可用于实现单例模式

  ```java
  public class JT {
      private static class SingletonHolder{
          private static final JT INSTANCE = new JT();
      }
      public static JT getInstance(){
          return SingletonHolder.INSTANCE;
      }
  }
  ```

## StackOverflow和OOM的区别和出现场景

* **StackOverflow是指调用的栈的深度已经超出限制**
* **OOM的出现场景主要是JVM栈溢出，堆空间不足**

## 什么情况下finally不执行

* try中调用了System.exit方法，直接终止了JVM的运行
* 在守护进程中运行的finally，守护进程：**一种长期运行的进程，这种进程在后台运行，并且不跟任何的控制终端关联。**

## Java内置的monitor锁的特征和实现方法

Java内置的monitor锁只要有**互斥和可重入**两个特征

互斥就是当一个线程持有锁的时候，其他的线程不能访问这块被锁住的内容

可重入是指当一个**线程持有锁的时候**，它可以**重复的请求并获得这个锁**

对于互斥和可重入的实现，JVM对**每个锁维护了一个计数器**：每当有线程获取锁时，计数器的值就+1，而当锁被释放，计数器的值就-1，只有当计数器的值为0的时候，锁才能被任意进程获取。

## Runnble和Callable接口的区别

Runnble接口无法返回值或抛出异常：Runnable接口定义的时候就默认不会抛出异常

Callable接口可以返回值，也可以抛出异常：配合FutureTask **FutureTask.get()**

run方法无返回值，call方法有返回值

## submit和execute的区别

**execute方法用于提交不需要返回值的内容**

**submit方法用于提交需要返回值的任务**

## volatile修饰符的作用

1. 保证有序性，**防止JVM的指令重排**，一般情况下JVM会对指令进行重排，而volatile修饰符可以防止JVM对相关指令的重排，确保并发下的有序性
2. 保证可见性，**JMM中**，每个线程都拥有自己的一块工作内存，线程可以把变量从主存中读取到工作内存中进行读写，这种情况下，一个线程对内存做出了修改，可能另一个线程无法看到，这样就无法保证可见性，而volatile修饰符可以标注变量，使得线程每次都会到主内存中对这个变量进行读写，从而保证了变量的可见性。

## 并发的三个重要特性

* 原子性：一个操作要么全部执行，要么不执行
* 可见性：当一个线程对共享的变量进行了修改，其他变量需要能够看到修改后的最新值
* 有序性：确保代码执行顺序的正确

## sleep和wait的区别

sleep不会释放锁，其还掌握着系统资源，而wait会释放锁，并且需要早notify之后重新竞争锁资源

## 为什么新建线程后要调用start方法而不是run方法

new的时候是新建态，start后是就绪态；如果只run，那么这个进程还是新建态，是主进程在调用run方法，并没有利用到新建的线程

## synchronized原理

1. 一个是修饰代码块，编译后就会在代码块前后加上monitorenter和monitorexit关键字，代表着获取monitor对象，代表着获取monitor锁，并且使计数器 + 1，monitorexit代表着释放锁，并且使计数器的值 - 1
2. 一个是修饰方法，修饰方法的时候会将**ACC_SYNCHRONIZED**标记在**运行时的常量池**中并被方法调用指令检测到。通过synchronized加锁时，会清除工作内存中的共享变量，从主内存中读取，释放时将共享变量写回主内存

## synchronized的使用方法

1. 修饰静态方法时是给当前类加锁
2. 修饰实例方法时是给当前对象加锁
3. 修饰代码块时我们可以自行指定加锁对象 而synchronized最常见的使用场景就是实现单例模式。

为什么单例模式双重检查的时候要用volatile呢？

因为防止指令重排：JVM在类初始化的时候会有几个步骤：编译、加载、连接（验证、准备、解析）、初始化

准备（给类对象分配内存空间并且附初值）和初始化（给类对象分配代码中负的值），这两个步骤可能会出现指令重排，如果发生指令重排，在单例模式下可能使得一个线程错误的使用了未被初始化的对象

## 乐观锁和悲观锁

乐观锁（CAS）就是修改的时候不加锁，提交的时候会检查在修改的时候是否有其他人进行了修改，如果有那么拒绝提交，如果没有，可以提交

悲观锁就是认为随时对对象进行修改，所以读写都要加锁

乐观锁的运用场景与悲观锁不同，一般来说：

- 悲观锁用于**写操作较多**的场景，加锁可以确保数据的正确
- 乐观锁则一般用于**读操作多、写操作少**的场景，无锁算法可以提高读的效率

## ReentrantLock（可重入锁）和synchronized区别

![](https://img-blog.csdnimg.cn/20201111200435712.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poZW5nemhhb3lhbmcxMjI=,size_16,color_FFFFFF,t_70)

ReemtrantLock是等待可中断的，而synchronized不行，使用ReentrantLock的时候，如果锁长期没有释放，那么线程可以放弃等待，而去处理其他任务。而使用synchronized的时候，线程就会一直等待，直到锁被释放

ReentrantLock支持公平锁（按照锁的申请顺序获得锁），synchronized不可以（非公平锁：先申请，无法获取时进入等待队列）

ReentrantLock可以绑定多个Condition对象，从而实现绑定多个条件，而synchronized只能绑定一个条件。

## 对象的内存分布

- **对象头**
- 实例数据
- 对齐填充

而**对象头**本身则主要包括两部分内容：

- Mark Word：当中包含了对象的hashcode、分代年龄、轻量级锁指针、重量级锁指针、GC标记、偏向锁线程ID、偏向锁时间戳。
- Klass Point：指向**类元数据的指针**，用于确定**对象是哪个类的对象**。

## AQS原理

我们常提到的ReentrantLock, Semaphore等都是基于AQS（Abstract Queued Synchronized）。

AQS的原理主要是内部维护一个用volatile修饰（为了确保线程可见性）的state状态位，尝试加锁的时候会通过CAS操作将其设为1，并且把当前线程ID赋值；而释放锁时会把state重新设为0，同时把当前线程ID置为空。

## 为什么需要线程池？

* 因为线程来回的切换，创建，销毁会消耗大量的资源
* 提高响应速度
* 提高可管理性

## 线程池的原理

线程池的生命周期

![](https://github.com/xuanqizi/JavaBagu/raw/master/images/Java/Java%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)

当我们用execute()提交一个任务之后，会进行以下的判断：

- 首先检测线程池状态，如果不是RUNNING，直接拒绝。
- 之后，如果当前工作线程数小于coreSize，新建并启动线程，直接执行。（注意，线程池在创建时并不会直接新建coreSize个线程，而是随着任务到来逐渐新建）
- 如果工作线程数大于等于coreSize，且阻塞队列未满，将任务加入到阻塞队列当中。
- 如果工作线程数大于等于coreSize，且阻塞队列已满，则创建并启动新的线程来执行新提交的任务。
- 如果工作线程数已达到maxSize，且阻塞队列已满，则拒绝该任务。 对于任务的拒绝，有以下的饱和拒绝策略：
- **AbortPolicy**：丢弃任务，并抛出RejectedExecutionException异常。
- **DiscardPolicy**：丢弃任务，且不抛出异常。
- **CallerRunsPolicy**：直接由提交任务的线程来执行此任务。
- **DiscardOldestPolicy**: 丢弃阻塞队列最前面的任务，然后重新提交本任务。

## Java内存屏障

Java的内存屏障主要有四种：

- Load Load，保证Load 2的读取操作一定不会重排到Load 1之前
- Load Store，保证读操作在写操作之前
- Store Load，保证写操作在可见之后才执行读操作
- Store Store，保证别的CPU一定先看到Store 1的数据，再看到Store 2的数据


JVM对于内存屏障最主要的运用就是实现volatile关键字：

我们知道，volatile的作用之一是**禁止指令重排**，这里的禁止指令重排其实是禁止写操作向前排、读操作向后排。而volatile实现防止指令重排的方式就是插入内存屏障，JVM的实现会在volatile读写前后均加上内存屏障，在一定程度上保证有序性。

## ThreadLocal是什么？

ThreadLocal数Thread内的局部变量，线程间内可见，其他线程不可见。

ThreadLocal的作用是使线程拥有对象的副本，使其线程封闭，即仅**在单线程内访问数据。**

一句话理解ThreadLocal，向ThreadLocal里面存东西就是向它里面的Map存东西的，然后ThreadLocal把这个Map挂到当前的线程底下，这样Map就只属于这个线程了。

## ThreadLocal和Synchronized区别

Synchronized是不同线程间共享变量解决并发，ThreadLocal是不同线程间隔离变量解决并发

## Java内存区域

* 程序计数器，负责存储下一跳的地址，字节码解释器负责修改程序计数器的值来执行指令
* 虚拟机栈，负责存储一些基本数据类型，负责服务与java语言方法的
* 本地方法栈，和虚拟机栈的功能相似，负责服务与本地方法的
* 堆，负责存储一些new出来的对象，GC主要工作于堆内存
* 方法区，负责存储一些静态类型的变量，类信息，常量

## Java创建对象的过程（***）

* 类加载检查：检查能否在方法区找到这个类的符号引用，并且这个符号引用带包合格类是否进行过加载连接初始化的类加载过程
* 分配内存：指针碰撞（把内存分为两块，通过一个指针来调整边界，标记复制和标记整理，线程不安全）和空闲列表（维护一个记录可使用内存块的列表）两种方法
* 初始化：三部分：将对象除了对象头的其他部分都初始化为0，填写对象头，执行init方法
* 将地址返回给引用：

初始化和将地址赋给引用这两个可能会JVM的指令重排，所以说这也是为什么单例模式中要给对象加volatile修饰

## Java对象的内存布局

对象头、实例数据和对齐填充

* Mark Word：类的基本信息
* Klass Point：类指针

## JVM如何判断对象需要被回收

1. RC算法：为每个对象添加一个计数器，记录指向这个对象的引用个数。这种方法实现相对比较简单，但问题在于无法解决循环引用的问题。
2. 可达性分析：从GC Roots出发，利用引用关系向下搜索，如果某个对象对于GC Root不可达，就说明这个对象不可能再被使用。

GC Root主要有：

* JVM栈中的对象
* 本地方法栈中的对象
* 方法区中的静态对象
* 方法区中的常量对象

## 有哪些常见的GC算法？

- **标记-清除算法**是在进行可达性分析之后，标记出所有需要回收的对象，并将其清除。标记-清除算法可能产生**内存碎片**，并且GC效率不稳定。
- **标记-复制算法**将Java堆的**新生代**划分为一块Eden区和两块Survivor区。87每次分配内存只使用Eden区和其中的一块Survivor区，发生GC时，将仍然存活的对象复制到另一块Survivor区。而如果剩余的Survivor空间不足以存放剩下的对象，剩余的对象就会通过**分配担保机制**进入老年代。标记-复制算法当中，如果Survivor区较大，就会造成比较严重的内存空间浪费；而如果Survivor区较小，就必须有额外的空间进行分配担保。
- **标记-整理算法**和标记-清除算法相似，但是清除的过程不是直接清除内存，而是将仍然存活的对象移动到内存的一侧。一般用于**老年代**的GC，移动对象的过程会触发STW。

## Minor GC、MajorGC、Full GC

Minor GC回收的目标是新生代GC，一般在Eden区满的时候发生

Major GC指发生在老年代的GC，对象从老年代消失时，我们说 “Major GC” 或 “Full GC” 发生了。**也就是在老年代空间不足时，会先尝试触发Minor GC。如果之后空间还不足，则触发Major GC。**Major GC的速度一般会比Minor GC慢10倍以上，STW的时间更长。

Full GC是收集整个**Java堆和方法区的GC**，发生情况如下：

- **老年代或方法区空间不足**
- 进入老年代的对象大于老年代可用内存
- **Minor GC后放入的Survivor区（To space）内存不足**
- **调用System.gc()**

**Full GC 是开发或调优中尽量要避免的。这样暂时时间会短一些**

**出现OOM一定会出现Full GC**

## 常用的垃圾收集器的特点

- **Serial/Serial Old**使用**单线程**进行GC，同时会暂停所有其他工作线程（STW），等到所有工作线程到达安全点之后，对于**新生代**使用**标记-复制算法**，对于**老年代**使用**标记-整理算法**。Serial/Serial Old的内存消耗最小，同时没有切换线程的开销。

- **ParNew**则是“多线程并行版”的Serial

- **Parallel/Parallel Old**支持**多线程**并行，其中**Parallel Scavenge**基于**标记-复制**算法，而**Parallel Old**基于**标记-整理**算法。它是以**吞吐量**为目标，而不是以响应时间为目标。目前JDK8就是使用Parallel Scavenge + Parallel Old。

- CMS

  则是以**最短停顿时间**为目标的垃圾收集器。它是以

  **标记-清除**

  算法为基础实现的，大致过程如下：

  1. **初始标记**：暂停其他所有线程，并记录与GC Root直接相连的对象，这个过程会发生STW。
  2. **并发标记**：同时开启GC线程和用户线程，记录可达对象。
  3. **重新标记**：为了修复并发标记阶段用户线程运行带来的可达性变化，这个过程也会发生STW。
  4. **并发清除**：开启用户线程，同时GC线程并发回收未被标记的对象。 在上述阶段当中，只有初始标记和重新标记阶段会发生**STW**。

- **G1**是面向服务器、响应时间优先的一款垃圾收集器，它可以充分利用多核环境来缩短STW的时间。与传统的GC收集器不同，G1收集器的不同代内存空间分布并不是连续的，而是被分为若干个Region。同时，G1还实现了一个**停顿预测模型**，使得用户可以指定期望的停顿时间。

  G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。G1的Young GC就是根据用户允许的收集时间，选择若干数量的年轻代Region进行GC；Mixed GC则选中所有年轻代的Region，以及一部分的老年代Region（根据收益选择）。

  需要注意的是，G1不支持Full GC，如果需要Full GC会调用Serial Old收集器进行。

  G1收集器的GC过程和CMS相似，分为初始标记、并发标记、最终标记和并发清除四个阶段。

- **ZGC**采用标记-复制算法，并且标记、转移、重定位阶段都是**并发**的，因此停顿时间很短。

## 类加载器的种类

- **BootstrapClassLoader**（启动类加载器）：由C++实现，负责加载JAVA_HOME/lib目录下的jar包和类
- **ExtensionClassLoader**（扩展类加载器）：负责加载JRE_HOME/lib/ext目录下的jar包和类
- **AppClassLoader**（应用程序类加载器）：面向用户的类加载器。

## 双亲委派模型

双亲委派模型是指，当类加载器需要**加载类**的时候，它会先把加载请求**委派给父加载器**，一直**递归到顶层**（即BootstrapClassLoader），当**父类无法完成这个加载请求时，子类才会尝试进行加载。**

## JDBC与双亲委派模型

但是JDBC可能会破坏双亲委派模型。

## JVM类加载的过程

Loading -> Linking（验证，准备，解析） -> initializing

Loading：将字节码送到JVM中

Linking：验证：代码是否有害；准备：将类变量进行初始化；解析：符号引用替换成直接引用

initializing：将代码中的初值赋给类变量

## Java的四种引用类型

* 强引用：无论空间是否充足，是否执行GC，强引用都不会被回收
* 软引用：当空间不足时，执行GC会把软引用的对象清除
* 弱引用：执行GC时就会清除弱引用
* 虚引用：一个标记，无实际意义

## Class.forName()和ClassLoader.loadClass()的区别

Class.forName只进行三大步骤中的加载，ClassLoader.loadClass会执行完三大步骤。Class.forName()会使用调用该方法的类的类加载器进行加载

## 栈的内存是如何回收的？

在方法执行结束之后，对应方法的栈帧就会被回收，而不像堆内存中需要GC去回收

## 什么是守护线程

守护线程是指**为其他线程服务的线程**（如GC线程）。**在JVM中，所有非守护线程都执行完毕后，无论有没有守护线程，虚拟机都会自动退出**。需要注意，守护线程不能持有需要关闭的资源。

## 什么是JVM的二次标记？

JVM在进行GC的过程中实际上会进行两次标记，**第一次是通过可达性分析**发现对象到GC Roots之间没有任何引用链相连。这时会出现两种情况，**如果对象没有重写finalize()方法，那么该对象就会被直接认为是可回收的；**而如果对象**重写了finalize()方法，并且该方法还没有被执行过**，这个方法就会被**放入F-Queue当中，F-Queue中的对象将会进行第二次标记。**

## Finalize()

这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前被自动调用的。

## 什么是CMS的浮动垃圾？

CMS在进行**并发标记**的过程中，用户线程仍在执行，这个过程中就可能会产生新的垃圾，而这些垃圾并不会在重新标记阶段被标记出来（重新标记阶段只负责处理那些之前被标记为垃圾，但在并发标记阶段又获得了引用的对象），需要等到下一次GC才能得到回收，这种对象就被成为浮动垃圾。

## 介绍一下Java的内存模型（JMM）

Java当中，所有实例对象、静态域以及数组元素存储在堆中，而局部变量和方法参数则存储在线程私有的栈中。我们这里讨论内存模型，主要讨论的就是前者，存储在堆中的变量。

Java将所有线程共享的变量存储在主存（Main Memory）当中，此外，每个线程还有其工作内存（也称为本地内存），工作内存中存储了变量的副本，线程对变量的操作都经由工作内存完成。（关于工作内存导致的可见性问题，可联系[Java并发-4](https://github.com/xuanqizi/JavaBagu/blob/master/docs/Java/Java并发.md#4-volatile修饰符的作用)中的volatile相关知识）

## Java多态的实现原理

多态的底层原理是动态绑定，即在运行时才将方法调用和方法实现绑定起来。

## ArrayList和LinkedList的区别

* ArrayList的底层是Object[]数组，而LinkedList底层是双向链表
* ArrayList因为是数组，所以当插入数据的时候，ArrayList会进行扩容
* 此外，因为ArrayList的底层数据结构是数组，因此ArrayList实现了**RandomAccess接口**，因为数组支持随机访问。数组存储空间是连续的，**因此可以根据数组地址以及数组下标直接计算出相应元素的地址。**

## ArrayList的扩容机制

- 首先获取数组的旧容量，然后计算新容量的值，计算使用位运算，将其扩容至1.5倍
- 得到新容量的值后，校验扩容后的容量是否大于需要的容量，如果小于需要的容量，则把最小需要容量当做扩容后的新容量
- 每次进行扩容，都需要通过Arrays.copyOf()方法将旧的数组深拷贝到新的数组当中，这样有较大的开销，因此，在插入大量数据之前，我们可以先调用ensureCapacity()方法来手动进行一次扩容。

## List，Set，Map的区别

- List存储的元素是有序、可重复的
- Set存储的元素是无序、不可重复的
- Map则是通过键值对进行存储的

## HashMap的底层原理

JDK1.8之后，Java的HashMap采用数组+链表+红黑树来实现。当插入一个数据，首先会计算其哈希值，并且根据哈希值计算出对应的数组下标。如果Map中已经存在这个key，就会替换value；而如果不存在这个key，就会插入新的节点。此时，如果出现哈希冲突，就会向链表当中继续插入值，而如果没有出现哈希冲突，就会在数组的相应位置放入一个节点。

如果加入的元素数量达到阈值（负载因子*容量，默认负载因子为0.75），则会对数组进行扩容；而如果链表的长度大于阈值（默认为8），也会对哈希表进行扩容，这里分两种情况：

- 如果数组的长度小于64，对数组进行扩容，将数组的长度扩容为2倍。数组的长度需要保持是2的倍数，因为只有当数组长度为2的倍数时，满足下式：
  $hash$ $%$ $n$ $=$ $hash$ $\And$ $(n-1)$


从而可以用位运算来简化取余的计算，提高效率。

因为数组是扩容为两倍，因此扩容之后Node的位置要么在原来的索引，要么位置在原索引+原数组大小处。因此，HashMap维护了两个临时链表引用，在分别用尾插法插入完成之后，再将这两个链表赋值到Node[]的对应位置。 + 如果数组的长度大于64，则将链表转化为红黑树。这样可以将哈希冲突时查询的时间复杂度从O(n)降低为O(logn)，而如果后续通过删除，树中的元素数量小于6，则会将红黑树转换回链表。

## LinkedHashMap的底层原理

LinkedHashMap是HashMap的子类，因此，其主要的底层数据结构与HashMap相似，同样包含一个节点数组，链表、红黑树，不同的是，LinkedHashMap的节点类在HashMap的Node类基础上新增了指向上一个节点和下一个节点的指针，也就是说，LinkedHashMap在HashMap的基础上增加了一条双向链表。

而LinkedHashMap的put操作时就增加了一步，即将**节点接在链表的末尾**。

## ConcurrentHashMap的数据结构

**JDK1.7之前**，ConcurrentHashMap是通过分段锁来实现线程安全的，它主要由**Segment[], HashEntry[]以及链表组成**。**Segment继承了ReentrantLock**，也就是说，**每一个段都是一个可重入锁**，当在某一段进行写入时，就会对这一段加锁。

如果扩容数组，会将数组大小扩容为2倍，之后会重新计算每个HashEntry的位置。扩容时会找到一个在这个节点之后的节点新位置全部一致的节点，并将这个节点直接移动到新数组的相应位置；剩余的节点使用头插法逐渐插入。

**JDK1.8之后**，ConcurrentHashMap不再使用Segment的分段锁机制，而是直接使用Node[]和链表、红黑树来实现，这种底层数据结构和HashMap非常相似。而与HashMap的区别在于，在操作的过程中加入了synchronized和CAS操作，从而保证了线程安全。在put的过程中，如果计算出的位置已经存在节点，会用**synchronized**锁住链表的首个节点，而不会影响Node数组中的其他Node，这样可以大幅度提高并发性。而如果计算出的位置暂时没有节点，会用**CAS**操作来插入新的节点。

## Synchronized锁升级

无锁 -> 偏向锁（一个线程多次尝试去获取锁） -> 轻量级锁（一旦有第二个线程加入**锁竞争**，偏向锁转换为**轻量级锁**（**自旋锁**）） -> 重量级锁（显然，忙等是有限度的（JVM 有一个计数器记录自旋次数，默认允许循环 10 次，可以修改）。如果锁竞争情况严重， 达到某个最大自旋次数的线程，会将轻量级锁升级为重量级锁）

## ConcurrentHashMap和Hashtable的区别

- **ConcurrentHashMap**在JDK1.7及以前使用分段锁的机制，在JDK1.8之后则是通过synchronized锁住Node来实现线程安全，因此，**无论是哪个版本的ConcurrentHashMap，在插入值时都只会给其中的一部分上锁。**

- 而**HashTable**每个对象使用**synchronized修饰方法，这样调用同步方法时整个对象都会上锁**，因此**并发性能较差**，目前已经基本不会使用Hashtable了。

## 谈谈并发容器

我们知道，Java当中普通的容器类，比如HashMap, ArrayList, LinkedList等都是线程不安全的。那么对于这个问题，首先Collections提供了一系列的静态方法，可以这些collection变为线程同步的。这种方法虽然解决了线程不安全的问题，但是这种同步化的容器性能非常的低。因此，在多线程环境下，我们应该使用JUC包（java.util.concurrent）提供的并发容器。

主要常用的并发容器有ConcurrentHashMap, CopyOnWriteArrayList, BlockingQueue等，其中： 

- **ConcurrentHashMap**是支持多线程并发操作的HashMap，它的底层数据结构是Node[]、链表、红黑树实现的。当调用put()方法时，如果计算出的位置之前没有节点，会通过**CAS操作来新建一个节点放入数组；而如果计算出的位置已经存在一个链表，就会用synchronized锁住这个位置链表的首个节点。**（CAS：Compare and Swap，比较并交换。在CAS操作中，涉及到三个值：内存值A，旧的预期值B，要修改的新值C。当且仅当预期值B和内存值A相同时，将内存值A修改为C，否则什么都不做，一般CAS都要配合无限while循环操作，不断的尝试知道修改完成）
- **CopyOnWriteArrayList**的add, set等操作，都是**加锁**并通过**复制**原来的数组，在新的数组上修改之后，再将数据引用转为指向修改完成的数组。这里加**ReentrantLock的目的是防止多个线程同时写入时拷贝出了多个副本，从而导致写入的数据丢失。**而因为修改并不进行在原来的数组上，所以读取时并不需要进行同步和加锁，同时写线程也不会阻塞读线程。因此，CopyOnWriteArrayList很适合**读多写少**的多线程环境。
- BlockingQueue则是阻塞队列，我们使用的线程池ThreadPoolExecutor就运用了阻塞队列。BlockingQueue是一个接口，常见的实现类有ArrayBlockingQueue和LinkedBlockingQueue，前者是通过数组实现的，而后者是通过链表实现的。

## HashMap的内存泄漏问题？

如果一个类的hashcode()方法被重写过，且hashcode()的返回值与成员变量有关，这个对象被设为key之后，再对其成员变量进行修改，就会导致内存泄漏。

这是因为在put时，我们根据当时对象的成员变量计算了哈希值，并计算出它的位置，之后，key的内容被修改，如果再次插入或是调用get时，计算得到的哈希值就会不同，从而就无法正确找到原来插入的键值对。

## CopyOnWriteArrayList插入过程中再次插入会如何？

CopyOnWriteArrayList的add方法中运用了**ReentrantLock**，因此在其中**一个线程进行add操作的时候，其他线程会阻塞等待获取锁，之后才进行add操作**。而对于同一线程，add操作是同步的，因此也需要等待前一个add操作结束之后才可以继续操作。

CopyOnWriteArrayList的数组标记了**volatile**，可以**防止指令重排**，从而避免指令重排导致的，**数组复制操作未完成前提前返回地址给引用的问题。**

## OSI七层模型是如何划分的？

物理层、网络链路层、网络层、传输层、会话层、表示层、应用层

- **应用层**是网络应用程序和它们的应用层协议存留的地方，比如常用的HTTP，SMTP, FTP, DNS都属于应用层。应用层协议主要是定义应用程序之间交互通信的规则。
- 表示层的作用是使得交换的应用程序能够解释交换数据的含义。
- 会话层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。
- **运输层**负责在应用程序端点之间传输应用层报文段（segment）。
- **网络层**负责将数据报（datagram）从一台主机发送到另一台主机。这期间网络层需要选择合适的网络路线和节点。
- **链路层**负责将整个链路帧从一个网络元素移动到邻近的网络元素。它先把IP数据报封装成链路层帧，然后在数据链路上进行传输，最后目的地将收到的链路层帧拆封，将其中的数据报上交给网络层。
- **物理层**则负责将数据的每一个bit移动到下一个网络节点。

## 从浏览器输入网址到显示出网页发生了什么？

首先，输入网址之后，浏览器会从URL当中抽取出主机名，并且将其发送给DNS客户端。

之后，DNS客户端会向本地DNS服务器发起请求（一般基于UDP），这时如果本地DNS服务器有这个域名的缓存，就会直接将IP地址返回给客户端，否则会迭代地查询根域名服务器、顶级域服务器、权威DNS服务器，这期间也是如果哪一步的结果已经被缓存就直接跳过，最终得到IP地址返回给客户端。

客户端得到这个IP地址之后，就可以通过这个IP地址来进行HTTP连接。

HTTP是通过TCP连接实现的，并且HTTP1.1之后，建立的是持续连接，也就是说这里TCP连接建立后会持续一段时间，直到有一段时间无响应之后服务器端才断开TCP连接。

因此得到IP地址之后，浏览器就与服务器进行三次握手，建立TCP连接，也就是

[![三次握手标记位](https://github.com/xuanqizi/JavaBagu/raw/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%A0%87%E8%AE%B0%E4%BD%8D.png)](https://github.com/xuanqizi/JavaBagu/blob/master/images/计算机网络/三次握手标记位.png)

建立了TCP连接之后，浏览器就会向服务器请求HTML文件以及一些资源文件，之后就通过WebKit来进行页面渲染。

## TCP三次握手的过程是什么？为什么要进行三次握手？

选择三次握手主要有两方面的原因：

- 第一是因为只有通过三次握手，才可以使连接双方都确认连接是正确的。如果只进行两次握手，那么服务端无法确认自己的发送是正确的，也无法确认客户端的接收是正确的。
- 第二是通过三次握手可以防止失效报文段带来的影响。如果只有两次握手，那么服务端收到失效报文段之后也会返回信息并与客户端进行连接，而如果有三次握手，在服务端收到失效报文段并返回ACK之后，客户端就不会与服务器进行第三次握手来建立连接。

## TCP四次挥手的过程和原因？

![](https://github.com/xuanqizi/JavaBagu/raw/master/images/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

四次挥手目的是确认双方都不再有待发送的数据。TCP是**全双工**的，也就是说双方都可以发送数据。发送FIN只表示一方没有要发送的数据了，但另一方可能还有要发送的数据。

## TCP UDP 区别

1. TCP面向连接（在发送数据之前要建立连接），UDP无连接（不需要建立连接）
2. TCP可靠传输，UCP不可靠传输
3. TCP一对一，UDP一对一一对多多对一多对多
4. TCP字节流，UDP是报文
5. TCP是拥塞控制，UDP无拥塞控制
6. TCP头部是20个字节，UDP头部8个字节
7. UDP不用维护连接状态表

## TCP是如何保证可靠性的？

1. 顺序号，确认号
2. 流量控制，拥塞控制
3. 三次握手，四次握手

## Cookie和Session的区别？

Cookie和Session都是存储用户状态的，存储用户回话，Cookie是Session的一种

* cookie数据存放在客户的浏览器上，session数据放在服务器上。
* cookie不是很安全，别人可以**分析存放在本地的cookie并进行cookie欺骗**，考虑到安全应当使用session。
* session会在一定时间内保存在服务器上。当访问增多，会比较**占用你服务器的性能**，考虑到减轻服务器性能方面，应当使用cookie。
* 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
* 可以考虑将**登陆信息等重要信息存放为session**，其他信息如果需要保留，可以放在cookie中。

## Token

Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。

### 如何使用Token

* 用设备号/设备mac地址作为Token（推荐）

  客户端在登录的时候获取设备的设备号/mac地址，并将其作为参数传递到服务端。

* 用session值作为Token

  客户端接收到用户名和密码后并判断，如果正确了就将本地获取sessionID作为Token返回给客户端，客户端以后只需带上请求数据即可。

## HTTP 1.0 和HTTP 1.1 HTTP 2.0的区别？

**1.0 -> 1.1：**

- 首先，HTTP1.0和HTTP1.1最主要的区别是**HTTP1.0是非持续连接**，而1.1默认是**持续连接**。持续连接意思是在HTTP1.1之后，客户端与服务器建立连接，传输对象之后不会立即关闭连接，接下来如果要继续传输对象就不需要再进行三次挥手。
- 同时，HTTP1.1也支持了流水线传输（也叫做**管线化**），也就是说**浏览器可以一次性将多个请求发送给服务器**，让服务器进行处理，而不需要再等待一个请求得到响应后再去进行下一个请求。
- 另外一个比较主要的更新就是增加了range头，从而**支持范围请求**，也就是我们可以只请求一个资源的一部分，在这之后我们**下载文件就可以进行断点续传了。**而服务端也可以将Accept-Range设为none来标识不支持range，这种情况下浏览器一般会禁用下载的暂停键。
- 此外，还有一些更新，比如添加了一些状态码，如409（冲突），410（Gone，表示资源已被永久删除），还有新添加了一些请求头，比如If-Unmodified-Since（如果在这之后被修改就返回412）.

**1.1 -> 2.0**

- 增加了**多路复用**的支持。所有**对同一域名的请求将通过一个TCP连接来完成**，一个TCP连接可以承载任意数量的双向数据流。多路复用和管线化的区别在于：
  - 管线化必须按序响应，如果前一个请求阻塞了，后面的响应也无法进行；
  - 而多路复用则是对二进制帧的传输，可以使得不同请求的帧混杂在一起进行传输，之后再拼装在一起。
- 同时，HTTP2.0还可以给**数据流设置优先级**，优先级高的数据流会被服务器优先响应。
- HTTP2.0还压缩了header，1.1以及之前，HTTP的请求头都是以文本传输，而2.0开始改为用二进制进行传输，同时传输双方各自缓存一张header field表，这样使得header的大小变小，并且避免了header的重复传输。

## GET和POST的区别

- GET产生一个数据包，POST产生两个。**GET会直接将请求头和数据一起发送，而POST会先发送请求头，得到100响应之后再继续发送数据。**
- 一般来说，GET是通过**参数**传输数据，而POST是通过**body**传输数据。但是这种情况并不绝对，我记得我在网络上看到过说GET和POST本质上其实是一样的，实际上GET也一样可以通过body传数据，比如用postman或者curl就可以在GET请求的body中附带数据。不过一般情况下，GET都是通过参数来传递数据的，比如ajax就不支持在GET请求的body添加数据。
- **GET请求会被浏览器主动缓存**，**而POST不会**。要防止缓存可以考虑在网址之后加一个key或者时间戳。
- **GET在回退的时候是没有影响的，但是POST回退会再次发送请求**。
- GET请求应该是**幂等**的，也就是说对同一URL进行多次请求的返回内容应该一致。

## HTTP和HTTPS的区别

实际上，我们可以认为HTTPS就是**HTTP+SSL/TLS**，在HTTP协议下，HTTP直接运行在应用层上，与TCP连接，而在HTTPS中，HTTP和TCP之间多了一层SSL/TLS，它们代替了HTTP的部分通信接口。

在连接过程上，HTTP是三次握手（TCP），而HTTPS是四次握手。



单纯的HTTP有一些不足，可能导致信息传输的不安全：

- **明文通信**
- **不验证通信方的身份**
- **不验证报文的完整性**

处理的方法就是HTTPS，HTTPS为HTTP提供了加密、认证以及完整性保护。



**加密**的方法一般分为对称式和非对称式两种：

- **对称加密**：双方都使用同一个密钥。这种方法的优点在于加密和解密速度快，但缺点在于必须双方提前商定密钥，或者随着请求将密钥一起发送，两种情况密钥都有泄露的风险。
- **非对称加密**：密钥由私钥和公钥组成，私钥仅由一方保管，而公钥可以发送给所有要请求它的人。相比起对称加密，非对称加密更加安全，但相对来说加密和解密也更慢。

HTTPS使用的则是混合式加密，在交换密钥的过程中使用非对称加密，成功交换密钥之后，则使用对称式加密，来提高效率。



**认证**则主要通过CA证书来完成，收到CA证书的客户端可以根据认证机构发出的公开密钥对证书上的数字签名进行验证。



**完整性保护**在TLS中主要通过**摘要算法**来实现。

HTTPS的四次握手大致过程如下：

- 首先客户端先发起第一次握手，向服务器发起请求。
- 之后服务器返回Certificate报文，其中包含公钥证书。（第二次握手）
- 客户端发起第三次握手，发送Client Key Exchange报文，将用公钥加密后的共享密钥发送给服务器。
- 服务器发起第四次握手，发送Change Cipher Spec报文。

## 为什么要通过三个冗余ACK进入快速恢复状态。

因为丢包一定会造成三个冗余ACK（当然，乱序也可能造成三个冗余ACK）。 假设后方还有超过3个包，丢包造成三个冗余ACK的概率为100%，而乱序导致的概率为40%（穷举顺序）

## Ping是用什么协议实现的？

Ping命令是通过ICMP协议实现的，**ICMP协议是网络层协议**。由于**IP协议不保证可靠连接**，因此对于**ping操作需要ICMP协议来实现，客户端向服务器发送一个类型为8的ICMP报文，如果没有异常，服务器会返回一个类型为0的响应报文。如果发生异常，比如超时（TTL减为0）、不可达，路由器就会发回对应的ICMP报文。**

## 什么是TCP粘包？如何解决？

TCP粘包就是指发送的**若干TCP包在接收方接收到时粘成了一个包**。这是因为TCP是面向流的协议，而不是基于包的协议，因此TCP只保证字节流的顺序。

因此，解决粘包需要在应用层实现，解决方式主要有：

- 固定消息的长度，便于接收端进行分包
- **将包的长度和包一起发送**
- 使用特殊标记来进行间隔

## 交换机和路由器的区别？实现原理？

- 交换机工作在**链路层**，根据**MAC地址**寻址；路由器工作在**网络层**，根据**IP地址**寻址。
- 交换机主要负责网络内部的数据转发，路由器负责不同网络的数据转发。

**路由器内部维护了一个路由表，记录目的网络和对应的下一跳路由器。**如果表中存有目的网络的信息，则将信息转发到对应的下一跳路由器；否则，转发到默认的下一跳路由器。

## TCP和UDP的包头保存了哪些内容？

TCP的包头存储的以下内容：

- **源端口号和目标端口号（各16位）**
- **seq（顺序号） 32位**
- **ack（确认号） 32位**
- **标志位**，如SYN ACK FIN URG等 (6位)
- 接收窗口大小 16位
- Checksum
- 紧急指针：如果URG为1，该指针用于标识紧急数据结束的位置

UDP包头存储了以下内容：

- **源端口号和目标端口号（各16位）**
- **长度（16位）**
- Checksum（16位，可选）

## 延迟ACK是什么

延迟ACK是一种可以将多个ACK一并发送的机制。

## IPv4和IPv6的区别？

- IPv4的地址为**32位**，IPv6的地址为128位，这使得IPv6的地址在未来也很难被消耗完。
- IPv6使得用户可以对**网络层数据进行加密和校验**，提高了安全性。
- IPv6增强了**对移动设备的支持**，使其切换链路时也不会丢失连接。

## TIME_WAIT数量太多怎么办？

如果在高并发的短连接下，就会出现很多TIME_WAIT，从而消耗大量的系统资源。可以通过修改tcp_tw_reuse或tcp_tw_recycle参数来缓解这种情况。

## 什么是SYN攻击？

SYN攻击是利用TCP三次握手的特性，大量地使用伪造的IP地址向服务器**发送SYN请求**，之后服务器会返回ACK并留下端口等待最终进行连接。而实际上攻击方并不会回应ACK，使得服务器保持在半开连接的状态，积压服务器负载，最终导致服务器无法正常提供服务。

## 常用的HTTP状态码

**10x 信息响应**

- **100 continue**：表示操作可以继续，POST请求会先把header发给服务器，得到100响应之后再发数据。

**20x 成功响应**

- **200 OK**：表示请求成功。
- **201 Created**: 表示已经新建了一个资源，一般是POST请求或者PUT请求的响应（但是实际上根据我之前对一些网站的抓包，感觉POST请求也大多数是回应200）

**30x 重定向**

- **300 Multiple Choice**: 表示有多个选择，用户或浏览器可以自行选择一个进行重定向。
- **301 Moved Permanently**: 表示所请求的资源已经被永久移动到新位置。
- **302 Found**: 表示请求的资源临时由新的URI提供。
- **304 Not Modified**: 表示GET的内容并未改变。
- **307 Temporary Redirect**：表示请求的资源临时重定向到了location的位置。状态码 307 与 302 之间的唯一区别在于，当发送重定向请求的时候，307 状态码可以确保请求方法和消息主体不会发生变化。如果使用 302 响应状态码，一些旧客户端会错误地将请求方法转换为 GET。

**40x 客户端响应**（一般是客户端的请求出现问题）

- **400 Bad Request**: 一般是客户端发出的请求语义有误或是参数错误。
- **401 Unauthorized**：表示未验证权限。
- **403 Forbidden**: 表示请求已经收到，但被拒绝执行。
- **404 Not Found**: 没有在服务器上找到请求的资源。

**50x 服务器响应**（一般是服务端出现问题）

- **500 Internal Server Error**: 服务器遇到无法处理的问题
- **501 Not Implemented**：这个方法不被服务器支持。（只有GET和HEAD是服务器必须支持的）
- **502 Bad Gateway**：表示从网关得到的消息是错误的。
- **503 Service Unavailable**：表示服务器没有准备好这个服务，一般是服务器宕机或者维护导致的。
- **504 Gateway Timeout**：表示网关响应超时。

## 进程和线程的区别

- 进程是资源分配的单位，线程是CPU调度的单位。进程的内存区域中有一部分区域是所有线程共享的，以JVM的内存区域为例，堆和方法区就是所有线程共有的。
- 因为线程的某些资源是共享的，所以一个用户级线程阻塞可能会导致整个进程中的其他线程阻塞。
- 线程的开销相对进程较小，而进程的创建、销毁、切换都会造成较大的开销。

## 用户级线程（协程）和内核级线程的区别

- 用户级线程的管理完全由**应用程序**通过线程库进行，系统内核并不知道这个线程的存在。内核级线程则**由操作系统内核进行调度**。
- 用户级线程的切换**并不需要进程切换到内核态**，因为所有线程管理的数据都存储在用户空间当中。**内核级线程的切换则需要进程切换到内核态。**
- **用户级线程可以直接运行在任何操作系统上**，而内核级线程不行。
- 一个**用户级线程阻塞会导致整个进程阻塞**，**内核级则不会出现这种情况**。
- **同一个进程下的多个内核级线程可以用多个处理器内核进行处理**，而用户级线程不行。

## 进程具有哪些状态？

进程的状态有五状态模型和七状态模型。

五状态模型将进程分为：新建、就绪、运行、阻塞、结束。

- **新建**表示进程正在被创建。
- **就绪**表示进程已经就绪，只要CPU分配运算资源就可以开始执行。
- **运行**表示进程正在CPU上运行。
- **阻塞**状态表示进程正在等待某一事件，比如等待I/O或是等待某个资源被释放，这时CPU不会将运算资源分配给它。
- **结束**状态表示进程正在结束，可能是因为正常结束或是某些原因中断。

七状态模型则在五状态模型的基础上，增加了**就绪/挂起**和**阻塞/挂起**两种状态。**在这两种状态下，进程不在内存中，而是在辅存（一般来说也就是指硬盘）**当中。一般来说系统会更倾向于挂起阻塞态的进程。

## 进程间通信（IPC）的方式

进程间通信的方式主要分为管道（分为匿名管道和有名管道）、信号、消息队列、共享内存、信号量和socket七种。

- **匿名管道**没有名字，是一种半双工的通信方式，也就是说匿名管道只支持单向数据流。此外，由于匿名管道没有名字，因此只能在有亲缘关系的进程之间进行传输，同时，管道传输的数据没有固定格式，需要双方进程提前约定格式。管道以FIFO的规则进行读写，不支持定位操作。
- **命名管道**则在文件系统中具有文件名，因此能够在本机的任意两个进程之间通信。命名管道与匿名管道一样是半双工、FIFO的。命名管道在写入时需要确定对方是否存在。
- **信号**是由进程产生并传递给操作系统，操作系统根据信号是否阻塞来决定是否传递给其他进程的。目标进程收到信号后，会根据信号的类型进行处理。常见的Ctrl+C，以及kill()都是信号；在Java使用当中，可以调用
- **消息队列**是存放在操作系统内核中的信息链表，消息队列可以FIFO地读取，也可以按照消息类型读取，比起管道更加灵活。此外，消息队列也不需要确定对方是否在等待。 Linux提供了msgget()函数用于创建消息队列，msgsend()发送消息，msgrcv()接收消息。
- **信号量**就是一个整数（也可能是0或1），当有进程或线程获取信号量时，进行P操作，将信号量-1，如果这时信号量为0，就阻塞等待；而当进程或线程释放信号量时，就进行V操作，将信号量+1.
- **共享内存**是内核留出的一块内存区域，将一块物理内存映射到多个虚拟地址，多个进程都可以读写这一块内存，是最快的IPC方式。
- **Socket**一般是用来进行网络通信的，而socket所在的是运输层，主要负责在进程之间通信，因此，socket也可以在本机的不同进程之间通信。

## 线程间同步的方式

线程间同步的方式有**互斥量、信号量以及事件。**

- **互斥量**本质上就是锁，**在访问共享资源之前对互斥量加锁，访问完成之后解锁互斥量。**
- **信号量**则是用来**解决互斥量只能管理单个共享资源的问题**，信号量本质上是一个整数，当有线程获取共享资源，即进行P操作，将整数-1，此时如果数为0，则线程阻塞等待；而当线程释放共享资源，即进行V操作，将整数+1。
- **事件**表示通过**wait/notify的操作进行线程同步。**

## 用户空间和内核空间

Linux按照特权的级别，将内存空间划分成了用户空间和内核空间。我们知道CPU的指令特权等级分为Ring 0 - Ring 3，实际上，R0就是内核态，而R3就是用户态，另外的两个等级在Linux和Windows当中都没有被使用。

内核空间中存放的主要是操作系统内核的代码和数据，也存储了各个进程的内核栈。而用户空间存储的主要就是进程的代码和数据，并且各个进程的用户空间是独立的。

当进程运行在内核空间中，我们就称进程处于**内核态**，而进程运行在用户空间时，我们就称进程处于**用户态**。需要进行系统调用的时候，进程就切换至内核态，这个时候进程就会使用内核空间中这个进程的栈，系统会把用户态堆栈的地址存储到内核态的栈里面，然后将堆栈指针指向内核栈。

## 32位的系统会给每个进程分配多大的内存空间？

32位的系统会给每个进程**分配4G**的虚拟内存空间，这是因为在32位系统当中，每个指针的长度是4字节，表示的范围就是0x00000000 ~ 0xFFFFFFFF，这里表示的恰好是4G的空间。

## 有哪些常见的内存管理机制？

分页、分段、段页式

- **分页式**是将内存分为固定大小的页，每个进程被划分到若干个不一定连续的页当中。分页式内存管理可能产生内部碎片，即页的内部可能有一部分空间无法被利用。
- **分段式**是将内存分为大小不一的段，段中存放一组相对完整的逻辑信息。分段式内存管理则可能产生外部碎片，即段与段之间可能出现无法被利用的空间。
- **段页式**是将分段式和分页式结合起来的机制，将程序分为多个段，又将每个段分为若干页。

## 什么是快表（TLB）

快表（TLB）可以理解成**页表的缓冲**，通常存储在MMU当中，**CPU进行寻址时会先到快表当中进行查找**，如果没有相应的页表项，才会读取内存，查询页表。 如果没有快表，每次读取内存中的数据都需要读取两次内存，有快表之后，如果快表当中存有页表项，就可以少读取一次内存。

## 缓冲区溢出是什么？

由于系统给**程序分配的内存空间是有限的**，因此我们如果**向缓冲区输入大量信息，就可能会导致堆栈溢出，从而修改其他地方的内存。**

## IO的多路复用 select() poll() epoll()的区别

IO多路复用（IO Multiplexing）是指单个进程/线程就可以同时处理多个IO请求。

文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。

- `select`：将文件描述符放入一个集合中，调用select时，将这个集合从用户空间拷贝到内核空间（缺点1：每次都要复制，**开销大**），由内核根据就绪状态修改该集合的内容。（缺点2）**集合大小有限制**，32位机默认是1024（64位：2048）；采用水平触发机制。select函数返回后，需要通过遍历这个集合，找到就绪的文件描述符（缺点3：**轮询的方式效率较低**），当文件描述符的数量增加时，效率会线性下降；
- `poll`：和select几乎没有区别，区别在于文件描述符的存储方式不同，poll采用链表的方式存储，没有最大存储数量的限制；
- `epoll`：通过**内核和用户空间共享内存**，避免了不断复制的问题；支持的同时连接数上限很高（1G左右的内存支持10W左右的连接数）；文件描述符就绪时，采用回调机制，避免了轮询（回调函数将就绪的描述符添加到一个链表中，执行epoll_wait时，返回这个链表）；支持水平触发和边缘触发，采用边缘触发机制时，只有活跃的描述符才会触发回调函数。

## 进程的调度算法有哪些？

- **先到先服务**（FCFS）：从就绪队列当中选择最先进入该队列的进程分配资源。（非抢占式）
- **短进程优先**（SPN）：从就绪队列当中选择运行时间最短的进程分配资源。（非抢占式）
- **最短剩余时间**（SRT）：会选择剩余时间最短的队列进程执行（抢占式）。
- **最高响应比优先**（HRRN）：会选择等待时间与执行时间比值最大的进程执行。（非抢占式）
- **Round-Robin**：每个进程分配一个时间片，轮流执行。（抢占式）
- **多级反馈队列**：创建多个就绪队列，一个进程就绪时，先放入一级队列，之后如果在一个时间片内没有完成，就放入二级队列，依次类推。而仅当一级队列空闲时，才会去执行二级队列中的进程。（抢占式）
- **优先权调度**：即优先级高的进程先执行。优先权调度算法又分为抢占式和非抢占式的。

## 什么是虚拟内存？

- 虚拟内存使得每个进程认为自己拥有一块独立的、连续的内存，从而使得进程对于内存的操作变得更加容易。
- 此外，虚拟内存也支持将内存的一部分内容存储到硬盘上，并在需要的时候进行交换。这里就涉及到分页置换算法。

**分页置换**，就是当要获取的页不在主存当中时，需要换掉主存中的页，并将所需的页从外存中读取出来。

分页置换算法主要有以下几种：

- **OPT**是最佳分页置换算法，即置换未来最迟被访问的页。但是这种算法是不可能实现的。
- **LRU** （Linux就使用的是LRU算法）
- **FIFO**
- **Clock**算法为每个页维护一个使用位，当需要置换页时，开始指针循环并将使用位置为0，直到遇到使用位为0的页，就将其置换出去。

## 什么是死锁？如何处理死锁？

死锁的发生有四个必要条件：**互斥**、**占有和等待**、**不可抢占**、**环路等待**。

对于死锁是处理方法主要有四种策略：

- 鸵鸟策略。即忽略死锁的问题。
- 死锁检测和恢复。这种策略不阻止死锁的发生，而是当死锁发生时检测并对其进行恢复。对单个资源是否发生死锁的检测主要通过判断是否存在环，对于多个资源则通过矩阵进行判断。
- 死锁预防。主要指破坏死锁的必要条件：比如规定所有进程在开始前获取所需的所有资源，就可以破坏占有和等待的条件。
- 死锁避免。死锁避免的常见算法是**银行家算法**。

## 银行家算法？

![](https://github.com/xuanqizi/JavaBagu/raw/master/images/OS/%E5%8D%95%E8%B5%84%E6%BA%90%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95c.png)

存在空闲资源数为2，当我们将资源分配给C后，C执行完毕，空闲资源将变为4，由此，我们又可以将资源分配给B或D。这样，我们就可以给出一个C→D→B→A的安全序列，因此，b处于安全状态。

## 反射

在代码运行之前，我们**不确定**将来会使用哪一种数据结构，只有在程序**运行时才决定**使用哪一个数据类，而`反射`可以在**程序运行过程**中动态**获取类信息**和**调用类方法**。通过反射构造类实例，代码会演变成下面这样。

```java
public Map<Integer, Integer> getMap(String className) {
    Class clazz = Class.forName(className);
    Constructor con = clazz.getConstructor();
    return (Map<Integer, Integer>) con.newInstance();
}
```

Java 反射的主要组成部分有4个：

- `Class`：任何运行在内存中的所有类都是该 Class 类的实例对象，每个 Class 类对象内部都包含了本来的**所有信息**。记着一句话，通过反射干任何事，先找 Class 准没错！
- `Field`：描述一个类的**属性**，内部包含了该属性的所有信息，例如**数据类型，属性名，访问修饰符**······
- `Constructor`：描述一个类的**构造方法**，内部包含了构造方法的所有信息，例如**参数类型，参数名字，访问修饰符**······
- `Method`：描述一个类的**所有方法**（包括抽象方法），内部包含了该方法的所有信息，与`Constructor`类似，不同之处是 Method 拥有**返回值类型**信息，因为构造方法是没有返回值的。

拿到 `Class`对象就可以对它为所欲为了：剥开它的皮（获取**类信息**）、指挥它做事（调用它的**方法**），看透它的一切（获取**属性**），总之它就没有隐私了。

- `实例.getClass()`：通过实例化对象获取该实例的 Class 对象

```java
SmallPineapple sp = new SmallPineapple();
Class clazz = sp.getClass();
复制代码
```

- `Class.forName(className)`：通过类的**全限定名**获取该类的 Class 对象

```java
Class clazz = Class.forName("com.bean.smallpineapple");
```

### 获取类中的变量（Field）

- Field[] getFields()：获取类中所有被`public`修饰的所有变量
- Field getField(String name)：根据**变量名**获取类中的一个变量，该**变量必须被public修饰**
- Field[] getDeclaredFields()：获取类中所有的变量，但**无法获取继承下来的变量**
- Field getDeclaredField(String name)：根据姓名获取类中的某个变量，**无法获取继承下来的变量**

### 获取类中的方法（Method）

- Method[] getMethods()：获取类中被`public`修饰的所有方法
- Method getMethod(String name, Class...<?> paramTypes)：根据**名字和参数类型**获取对应方法，该方法必须被`public`修饰
- Method[] getDeclaredMethods()：获取`所有`方法，但**无法获取继承下来的方法**
- Method getDeclaredMethod(String name, Class...<?> paramTypes)：根据**名字和参数类型**获取对应方法，**无法获取继承下来的方法**

### 获取类的构造器（Constructor）

- Constuctor[] getConstructors()：获取类中所有被`public`修饰的构造器
- Constructor getConstructor(Class...<?> paramTypes)：根据`参数类型`获取类中某个构造器，该构造器必须被`public`修饰
- Constructor[] getDeclaredConstructors()：获取类中所有构造器
- Constructor getDeclaredConstructor(class...<?> paramTypes)：根据`参数类型`获取对应的构造器

## 注解

**想像代码具有生命，注解就是对于代码中某些鲜活个体的贴上去的一张标签。简化来讲，注解如同一张标签。**

注解通过 `@interface` 关键字进行定义。

```
public @interface TestAnnotation {
}复制代码
```

它的形式跟接口很类似，不过前面多了一个 @ 符号。上面的代码就创建了一个名字为 TestAnnotaion 的注解。

你可以简单理解为创建了一张名字为 TestAnnotation 的标签。

上面创建了一个注解，那么注解的的使用方法是什么呢。

```
@TestAnnotation
public class Test {
}复制代码
```

创建一个类 Test,然后在类定义的地方加上 @TestAnnotation 就可以用 TestAnnotation 注解这个类了。

### 元注解

元注解是可以**注解到注解上的注解**，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。 

如果难于理解的话，你可以这样理解。元注解也是一张标签，但是它是一张特殊的标签，它的作用和目的就是给其他普通的标签进行解释说明的。

元标签有 @Retention、@Documented、@Target、@Inherited、@Repeatable 5 种。

### @Retention

Retention 的英文意为保留期的意思。当 @Retention 应用到一个注解上的时候，它解释说明了这个注解的的存活时间。

它的取值如下： 
 \- RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。 
 \- RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。 
 \- RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。

### @Documented

顾名思义，这个元注解肯定是和文档有关。它的作用是能够将注解中的元素包含到 Javadoc 中去。

### @Target

Target 是目标的意思，@Target 指定了注解运用的地方。

### @Inherited

Inherited 是继承的意思，但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。  说的比较抽象。代码来解释。

### @Repeatable

Repeatable 自然是可重复的意思。@Repeatable 是 [java ](https://link.juejin.cn/?target=http%3A%2F%2Flib.csdn.net%2Fbase%2Fjava)1.8 才加进来的，所以算是一个新的特性。

