---
layout:     post
title:     计算机网络（第二轮 2022.3.24）
description:     Project JOB
date:     2022-03-24
author:     POt
header-img:     img/post-bg-kuaidi.jpg
catalog: true
category: blog
tags:     
    -   
        -   

    -   

---

## 协议栈

### OSI协议参考模型

**7层：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层**（物联网淑慧试用）

- 应用层：应用层协议定义的是应用进程间的通信和交互的规则，不同的网络应用需要不同的应用层协议
- 表示层：把数据转换为能与接收者的系统格式兼容并适合传输的格式
- 会话层：在数据传输中设置和维护电脑网络中两台电脑之间的通信连接
- 传输层：向两台主机进程之间的通信提供**通用的**数据传输服务
- 网络层：基于网络层地址（IP地址）进行不同网络系统间的路径选择
- 数据链路层：在不可靠的物理介质上提供可靠的传输
- 物理层：在局域网上透明地传送比特，尽可能屏蔽掉具体传输介质和物理设备的差异

### TCP/IP协议参考模型

五层：网络接入层、网络层、传输层、应用层（网网输用）

- 应用层：对应于 OSI 参考模型的应用层，为用户提供所需要的各种服务。定义的是应用进程间的通信和交互的规则，不同的网络应用需要不同的应用层协议。协议包括 SMTP、HTTP、FTP 等
- 传输层：对应于 OSI 参考模型的传输层，为应用层实体提供端到端的、**通用的**通信功能，保证了数据包的顺序传送及数据的完整性。“通用的”是指不同的应用可以使用同一个运输层服务。协议包括 TCP、UDP 等
- 网络层（或网际互联层）：对应于 OSI 参考模型的网络层，主要解决主机到主机的路由问题。协议包括 IP、ICMP 等
- 网络接入层：对应于 OSI 参考模型的物理层和数据链路层，负责相邻的物理节点间的可靠数据传输。协议包括 ARP、IEEE 802.2 等

### TCP/IP参考模型各层协议

![](https://s2.loli.net/2022/03/24/LjAHPuvI7nD4oBt.png)

### 比较TCP/IP参考模型和OSI参考模型

共同点：

- 都采用了层次结构的概念
- 都能够提供面向连接和无连接的通信服务机制

不同点：

- OSI 采用了七层模型，而 TCP/IP 是四层
- OSI 是一个在协议开发前设计的、有清晰概念的模型；TCP/IP 是先有协议集然后建立的、事实上得到广泛应用的弱模型，功能描述和实现细节混在一起
- OSI 的网络层既提供面向连接的服务，又提供无连接的服务；TCP/IP 的网络层只提供无连接的网络服务
- OSI 的传输层只提供面向连接的服务；TCP/IP 的传输层即提供面向连接的服务 TCP，也提供无连接的服务 UDP

## 集线器、网桥、交换机、路由器

* 网线是物理层的硬件

- 集线器（Hub）是**物理层**的硬件，连接所有的线路，广播所有信息
- 网桥（Bridge）是**数据链路层**的硬件。网桥隔离两个端口，不同的端口形成单独的冲突域，减少网内冲突。网桥在不同或相同类型的 LAN 之间存储并转发数据帧，根据 MAC 头部来决定转发端口，显然是数据链路层的设备
- 交换机（Switch）是**数据链路层**的硬件，相当于多端口的网桥。交换机内部存储 MAC 表，只会将数据帧发送到指定的目的地址
- 路由器（Router）是**网络层**的硬件，根据 IP 地址进行寻址，不同子网间的数据传输隔离

### 每一层常见的协议与作用

### 比特、帧、数据包、数据段、报文

PDU：Prtocol data unit，协议数据单元，指对等层协议之间交换的信息单元。PDU 再往上就是数据（data）。

在 OSI 模型里，PDU 和底下四层相关：

- 物理层———**比特（Bit）**
- 数据链路层———**帧（Frame）**
- 网络层———**分组、数据包（Packet）**
- 传输层———**数据段（Segment）**

第五层或以上为**数据（data）**。也有一种说法是，应用层的信息称为**消息、报文（message）**，表示完整的信息。

## TCP流量控制

### TCP流量控制机制

#### 窗口

![](https://coolshell.cn/wp-content/uploads/2014/05/sliding_window-900x358.jpg)

上图中，我们可以看到：

- 接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。

- 发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。

于是：

- 接收端在给发送端回ACK中会汇报自己的**AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;**（滑动窗口大小 = 缓冲区最大容量 - 收到的包的最后一个位置）

- 而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。

#### 滑动窗口原理

AB两台主机之间要互相发送数据，A向B发送，B向A进行流量控制。

滑动窗口大小由接收方决定，接收方将滑动窗口大小放入TCP报文的窗口**缓冲区**中。

发送方收到确认报文后，根据报文动态调整滑动窗口大小

#### 零窗口

**如果接收端处理过慢，则将窗口值置位0，则进入零窗口**

零窗口时双方均不发送消息，发送方启动一个计时器，计时器超时后向接收方发送1字节的探测报文，查询当前窗口大小。若窗口为0，则继续等待，不为0，则窗口大小，继续接受数据。

#### Nagle算法

如果接收端处理过慢，每次窗口只能接收几个字节，**那么当发送端每次都发送这几个字节时，会有大量带宽浪费在TCP/IP的首部上**，因此Nagle提出了Nagle算法。**Nagle算法的工作方式是【缓存 / 累计】要发送的小数据，直到滑动窗口值大于MSS（max Segment Size，TCP报文段一次可传输的最大分段大小）时再一并发送**

### TCP拥塞控制机制

#### 慢启动

拥塞窗口值以指数大小增长，直到大于等于门限值时慢启动结束

#### 拥塞避免

到达门限值时，拥塞窗口大小以+1+1的形式增加，直到网络阻塞

#### 超时重传

当网络发生阻塞时，将门限值大小置为当前拥塞窗口的一半，拥塞窗口置为0，从慢启动开始

#### 快速重传 / 快速恢复

快重传：接收端收到乱序包时，会发送`duplicate ACK`通知发送端，当发送端收到三个ACK时，就会立即开始重传未到达的数据包

快恢复：门限值降为拥塞窗口的一半，拥塞窗口降为拥塞窗口的一半，并进行拥塞避免算法。

（为什么可以执行拥塞避免算法呢？因为已经进行完快重传算法，说明网络此时是通畅的）

## TCP的三次握手和四次握手

### TCP标志位

1. **SYN**（synchronous）： **发送/同步标志，用来建立连接**，和 ACK 标志位搭配使用。A 请求与 B 建立连接时，SYN=1，ACK=0；B 确认与 A 建立连接时，SYN=1，ACK=1
2. **ACK**（acknowledgement）：**确认标志**，表示确认收到请求
3. PSH（push） ：**表示推送操作**，就是指数据包到达接收端以后，不对其进行队列处理，而是尽可能的将数据交给应用程序处理
4. **FIN**（finish）：**结束标志**，表示关闭一个 TCP 连接
5. RST（reset）：**重置复位标志**，用于复位对应的 TCP 连接
6. URG（urgent）：**紧急标志**，用于保证 TCP 连接不被中断，并且督促中间层设备尽快处理

### 三次握手、四次握手过程

![](https://imageslr.com/media/15942212152079.jpg)

三次握手：

1. Client将SYN置1，生成SequenceNumber发送给Server
2. Server收到后将SYN置为1，ACK置为1，将AcknowledgeNumber = SequenceNumber + 1发送给Client
3. Client接受后将ACK置为1，验证AcknowledgeNumber = SequenceNumber +  1，验证通过后连接成立

四次挥手：

![](https://imageslr.com/media/15942266727771.jpg)

1. Client将FIN置为1，生成SequenceNumber发送给Server
2. Server收到后将ACK置为1，将AcknowledgeNumber =SequenceNumber + 1发送给Client
3. 待全部数据传输完成后将FIN置为1，发送SequenceNumber给Client
4. Client收到后将ACK置为1，验证AcknowledgeNumber = SequenceNumber + 1，并将AcknowledgeNumber = SequenceNumber + 1 发送给Server端。此时Client端等待两个MSL后关闭，Server端验证AcknowledgeNumber = SequenceNumber + 1后自行关闭

### 握手阶段、传输阶段、挥手阶段的序列号与确认号

序列号（Sequence Number），确认号（Acknowledge Number）

#### 序列号（Sequence Number）

- 在 SYN flag 置 1 时，表示当前连接的初始序列号（Initial Sequence Number，ISN）
- 在 SYN flag 置 0 时，表示当前报文段中的第一个字节的序列号

序列号的规则：

- 握手阶段，`[SYN]` 包即使没有传送数据，也会消耗一个序列号。因此，建立连接后的序列号从 `ISN+1` 开始
- 挥手阶段，`[FIN/ACK]` 包即使没有传送数据，也会消耗掉一个序列号
- 数据传输阶段，序列号 = 第一个报文段的序列号 + 已经发送的字节数
  - 比如第一个报文段的序列号为 `S`，已经发送了 100 个字节，则下一个报文段的序列号为 `S+100`
  - 如果某个报文段不携带数据，不会消耗序列号，下一个报文段还是用相同的序列号发送
  - 正常情况下，B 给 A 的确认号，就是 A 下一个报文段的序列号
- 客户端三次握手第三步的 `[ACK]` 包，和传输阶段的第一个报文段，有相同的序列号

#### 确认号 Acknowledge Number

- ACK flag 置 1 时才有效，表示接收方期待的下一个报文段的序列号。一般是上次收到的报文段 seq + 1

### 为什么需要三次握手，而不是两次或四次

### 为什么需要四次握手，而不是三次

### 为什么客户端TIME_WAIT需要等待2MSL

### TIME_LIMIT是哪一方会进入的状态？

### SYN攻击的原理





