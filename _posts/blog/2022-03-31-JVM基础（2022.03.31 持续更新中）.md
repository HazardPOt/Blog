---
layout:     post
title:     JVM基础（2022.03.31 持续更新中）
description:     Project JOB
date:     2022-03-31
author:     POt
header-img:     img/post-bg-kuaidi.jpg
catalog: true
category: blog
tags:     

    -   
        -   
    
    -   

---

## JVM

JVM支持着java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。

## JVM内存分配

Java虚拟机规范汇总规定了五种虚拟机运行时的数据区，分别是：**程序计数器**、**Java虚拟机栈**、**本地方法栈**、**本地方法区**、**Java堆**、**以及方法区**，如下图所示：

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wOS1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC9lZjYzN2ZhYTg1M2Y0MTQyYjBiYjI4NjBjMmQzMjgyZH50cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png)



### 程序计数器（Program Counter）

程序计数器是用于存放**下一条指令**所在单元地址的一块内存，在Intel x86微处理器中，被称作**指令指针**（instruction pointer），在JVM中，程序计数器是一块较小的内存空间，可以看做是**当前线程所执行字节码的行号指示器**。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器完成。

多线程的情况下，线程是由CPU调度来执行指令的，在单核CPU中，某一时刻只会有一个线程在执行指令，这就意味着CPU会**频繁切换线程**，而线程切换后需要恢复到正确的执行位置，这就需要**每条线程都有一个独立的程序计数器**，各个线程间切换计数器不受影响。

JVM对程序计数器没有OutOfMememoryError（内存溢出）的限制，可能是因为程序计数器所占空间太小了，加之线程数是有限的，所以，规范中并未对其做任何约束限制。

程序计数器总结：

1. 程序计数器是一个指向下一条地址的内存空间
2. 每个线程都有自己的程序计数器，**是线程私有的**
3. 程序计数器不占空间且线程有限，是JVM内存中唯一一个没有内存溢出（OutOfMemeoryError）的区域
4. **字节码解释器通过给改变计数器的值来执行指令**

### Java虚拟机栈（Java Virtual Machine Statcks）

提起Java的栈内存，大家都不陌生，“**栈内存是用来存储基本数据类型和对象的引用的**”，这只是Java虚拟机栈的一部分。

虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个**技术栈帧**用于存储**局部变量表、操作数栈、动态链接、方法出口**等信息。**每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机中入栈到出栈的过程**。

**而我们平时说的“栈内存”，其实指的是虚拟机中局部变量表部分**，局部变量表存放了编译器可以直到的基本数据类型（boolean, type, char, short, int, final, long, double）、对象引用和returnAddress类型。其中long和double类型的数据会占用两个局部变量空间，其余的数据类型只占有一个。而局部变量表所需要的空间实在编译期间完成分配，当进入一个方法时，这个方法需要在栈中分配多少空间是完全确定的，在方法的运行期间不会改变局部变量的大小。

同时，**Java虚拟机栈与程序计数器一样是线程私有的**。Java虚拟机栈的生命周期与线程相同。另外，在Java虚拟机规范中对这一区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，就会抛出**StackOverFlowError**异常（递归没有返回条件时经常报这个错）；如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存就会报**OutOfMemoryError**异常

虚拟机栈总结：

* **虚拟机栈是线程私有的**，生命周期与线程相同
* “栈内存”多指局部变量表，是虚拟机栈的一部分
* 虚拟机栈描述的是Java方法执行的内存模型（栈帧）
* Java虚拟机内存不足时会抛出StackOverflowError异常和OutOfMemoryError异常

### 本地方法栈（Native Method Stack）

#### Native Method

Native Method，本地方法，在Java源程序中以关键字`native`声明，不提供函数体，就是一个Java调用非Java代码的接口。一个Native Method是这样的一个Java方法：**该方法的实现是由非Java语言实现，比如C**，但这个特征并非Java所持有，很多其他的编程语言都有这一机制。

本地方法栈和虚拟机栈的作用是非常类似的，他们之间的区别不过是虚拟机栈是虚拟机为执行Java方法服务，而**本地方法栈是为虚拟机用到的Native方法服务**。

本地方法栈总结：

1. Java虚拟机栈是为执行Java方法服务的，本地虚拟机栈是为执行Native（本地）方法服务的。
2. 某些虚拟机本地方法与虚拟机栈合二为一
3. 本地方法栈区域内存不足时会抛出StackOverflowError异常和OutOfMemoryError异常

### Java堆

**我们创建的对象实例几乎都是存放在堆内存中的**，因此，**Java堆是虚拟机所管理的最大的一块内存区域。****Java堆是被所有线程共享的区域**，在虚拟机启动时创建。Java虚拟机规范中对堆内存有这样的描述：**所有的对象实例以及数组都要在堆上进行分配**，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都在堆上分配也不是那么绝对了。

对于Java堆内存我们还可以进行一个细分：新生代（Young Generation）、老年代（Old Generation）；而新生代还可以分为Eden空间、From Suivivor空间、ToSurvivor空间。

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC8xZGUwNGMyMmI5NGM0MzIyYTAwNGFlY2FmNWU5MDY4OX50cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png)

**而Java中的垃圾回收就是针对Java堆上不同的区域进行扫描回收**

从内存分配的角度来看，线程共享的Java堆中可能划分出多个线程私有的缓冲区（Thread Local Allocation Buffer，TLAB).

但是，无论怎么划分，堆上所存放的内容都是对象的实例。进一步划分只不过是为了更好的回收内存或者更快的分配内存。

另外，Java虚拟机规范中规定，Java堆可以处于物理上不连续的内存空间中。**如果虚拟机在为实例分配内存时没有足够的空间，并且堆也无法在扩展**，则会抛出**OutOfMemoryError**异常。

Java堆总结：

* Java堆是所有线程共享的
* **Java中创建的对象几乎都存放在堆内存中**（new的都放在堆内存中）
* 垃圾回收机制会对堆内存进行扫描和垃圾对象的回收
* 堆内存会抛出OutOfMemory（内存溢出）异常



### 方法区（Method Area）

方法区是用来**存储**虚拟机加载的**类信息、常量、静态变量**、即时编译器编译的代码等数据。**方法区与堆内存一样是所有线程共享的一块区域**。Java虚拟机对于方法区的限制非常宽松，因此也就导致了不同虚拟机上方法区有不同的表现。**方法区在JDK1.7之前是一块单独的区域**，**使用永久代来实现了方法区**，这样更容易出现内存溢出的问题。而HotSpot的团队显然也意识到了这点问题，因此，**在JDK1.7中将方法区中的字符串常量池移到了堆内存中**，并在**JDK1.8中完全废除了“永久代”，使用元空间替代了永久代。**

方法区总结：

* 方法区与堆内存一样是所有线程共享的区域
* 常量、静态变量、类信息等存储在方法区
* 不同的虚拟机对方法区的实现不同
* HotSpot虚拟机在JDK1.7中将字符串常量池移到了堆内存，并在JDK1.8中用元空间去掉了“永久代”。
* 方法区内存不足时会抛出OutOfMemoryError异常

### 常量池（Pool）

#### 字符串常量池（String Pool）

字符串属于引用类型，是Java中使用最频繁的一种数据类型，因此，为了节省内存，提高性能，Java开辟了一块叫字符串常量池的区域，用来存储一些全局的字符串。**字符串常量池是所有类公用的一块空间**，在一个虚拟机中只有一块常量池区域。**在类加载完成后，经过验证，准备阶段之后在堆中生成字符串实例，然后将该字符串对象实例的引用值存到字符串字符串常量池中。**JDK1.7之前是存在方法区的，JDK1.8之后移到了堆内存中。

#### Class文件常量池（Class Constant Pool）

Java文件在通过javac编译后会生成Class文件，Class文件中除了存放类的版本、字段、方法、接口等描述信息外，还有一项是**常量池（Constants Pool Table）**，常量池用于存放编译期间生产的各种字面量和符号引用。

#### 运行时常量池（Runtime Constant Pool）

运行时常量池是方法区的一部分，虚拟机会在类加载后将存Class文件常量池的内容加载到运行时常量池。因此，每一个类都会有一个运行时常量池。运行时常量池相对于Class文件常量池有具备动态性。**由于运行时常量池属于方法区，因此其内存限制自然与方法区无异，当常量池无法再申请到内存时会抛出OutMemoryError异常。**

[深入JVM--Java运行时内存区域详解](https://zhpanvip.gitee.io/2020/09/04/26.JVM%20memory/)

## JVM垃圾回收机制（GC机制）

### GC机制概述：

我们知道对象的创建是由JVM完成的，在对象创建的时候JVM会在Java堆中开辟一块空间用来存储这个对象。而当对象“死亡”的时候，同样是由JVM来处理的，JVM处理“死亡”对象的过程就是我们今天要讲的垃圾回收机制。

### 堆内存的区域划分

为了更方便JVM管理和回收对象，Java将堆内存划分为两大块，新生代（Young Generation）和老生代（Old Generation）。根据新生代的特性，又将新生代分为，**较大的**Eden区域和**两块大小相等**的Survivor区域（FromSurvivor，ToSurvivor）

再来看一看垃圾回收的特点，垃圾回收器在执行一次垃圾回收时，可能是**部分收集（Partical GC）**，也有可能是**整堆收集（Full GC）**，部分收集可以分为新生代收集（Minor GC / Young GC），和老年代收集（Major GC / Old GC）。

回收区域的规则为：只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行Full GC。

对象通常是在Eden区域被创建，JVM会给每个对象定义一个年龄（Age）计数器，存储在对象头中。如果经过第一次Minor GC后对象仍然存活，并且能被Survivor区域容纳的话，对象则会被移动到Survivor区域，同时会将对象的年龄设置为1岁。接下来，该对象会经历多次的垃圾回收，Survivor区中的对象每熬过一次Minor GC，它的年龄就会增加一岁。**如果对这个象增加到一定年龄（默认15，可通过-XX:MaxTenuringThreshold参数设置），就会被移动到老年代中。**

### 永久代（Permanent Generation）

在JDK7以及之前，HotSpot虚拟机还有另外一块叫**永久代（Permanent Generation）** 的存储区域，**这块区域并不属于堆内存，而是对于方法区的实现。主要用于存放Class和Meta（元数据）的信息，Class在类加载的时候被放入永久代。**

**虽然被称为永久代，但这块内存区域也会进行垃圾回收。永久代的垃圾收集主要包废弃常量和无用的类**（被类加载器卸载的Class）。永久代触发垃圾回收的条件比较困难，需要同时满足以下三点：

- 该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；
- 加载该类的ClassLoader已经被回收；
- 该类对应的java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法；

所以这也导致了**永久代的区域会随着加载的Class的增多而爆满，最终抛出OOM异常。**

### 元空间（MetaSpace）

由于永久代可能存在内存溢出的问题，在JDK8之后永久代已经不复存在，取而代之的是**元空间（MetaSpace）**。

**元空间的本质和永久代类似，都是对JVM规范中方法区的实现。**不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是**使用本地内存**。

有关垃圾回收的区域如下图所示：

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9wMS1qdWVqaW4uYnl0ZWltZy5jb20vdG9zLWNuLWktazN1MWZicGZjcC8xZGUwNGMyMmI5NGM0MzIyYTAwNGFlY2FmNWU5MDY4OX50cGx2LWszdTFmYnBmY3Atem9vbS0xLmltYWdl?x-oss-process=image/format,png)

### 为什么要进行回收标记？

垃圾回收器回收垃圾的第一步就是要确定哪些对象是可以被回收的。因此，JVM会扫描堆内存中的所有对象，并标记出可被回收的对象。而垃圾收集的标记算法有以下两种：

### 引用计数算法进行垃圾收集标记

引用计数算法通过在每个对象中添加一个计数器，**当有一个地方引用它的时候计数器的值就会增加1；当引用失效的时候计数器的值则会减1。当计数器的值为0时，则可认为这个对象已经不再使用。**因此对于引用计数算法，**垃圾收集器只需要回收计数器为0的对象即可。**（每个对象添加计数器，引用 + 1，不引用 - 1，0时回收）

### 可达性分析算法进行垃圾收集标记

可达性分析算法也被称为根搜索算法。这一算法的基本思路是用一系列的**“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索**，搜索过程所走过的路径被称为”引用链“（Reference Chain）。**如果一个对象到”GC Roots”没有任何的引用链相连，则证明此对象可能不再被使用。**

![](https://img-blog.csdnimg.cn/20200913231357979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTIxNTcz,size_16,color_FFFFFF,t_70#pic_center)

哪些对象可以被作为GC Roots呢？**大部分引用的对象**

### 使用标记-清除算法（Mark-Sweep）进行垃圾收集

标记-清除算法是最早出现也是最基础的一种垃圾收集算法。**该算法分为“标记”和”清除“两个阶段**，标记阶段就是上边讲到的对垃圾的标记。首先会通过**可达性分析**算法标记出所有需要回收的对象，然后**统一回收掉所有被标记的对象**。标记-清除算法的执行过程如下图所示：

![](https://img-blog.csdnimg.cn/202009170053267.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIwNTIxNTcz,size_16,color_FFFFFF,t_70#pic_center)

图中深灰色区域为可回收区域，在标记完成后直接将深灰色区域进行清理。这一算法很容易理解，实现起来也很便捷，但是也存在两个缺点：

1. **执行效率会随对象增多而降低。**如果Java堆中包含大量需要回收的对象。此时需要**进行大量标记和清除操作**。导致标记和清除这两个过程需要大量的时间，降低了执行效率。

2. **引起严重的内存碎片化问题**。标记、清除之后会**产生大量不连续的内存空间**，这可能会导致在需要**分配大对象时无法找到足够的连续空间**，进而引发GC。

