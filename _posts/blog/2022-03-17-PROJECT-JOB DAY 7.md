---
layout:     post
title:     PROJECT-JOB DAY7
description:     Project JOB
date:     2022-03-17
author:     POt
header-img:     img/post-bg-kuaidi.jpg
catalog: true
category: project
tags:     
    -   
        -   

    -   

---
## Java基础
复习：https://github.com/rbmonster/learning-note/blob/master/src/main/java/com/toc/JAVA_BASE.md


复习：https://github.com/rbmonster/learning-note/blob/master/src/main/java/com/toc/COLLECTION.md
## 计网基础
复习：https://github.com/wolverinn/Waking-Up/blob/master/Computer%20Network.md
## SQL
### 创建高级联结
#### 自联结
> SELECT c1.cust_id, c1.cust.name, c1.cust.contact
> **FROM Customers AS c1, Customers AS c2**
> **WHERE c1.cust_name = c2.cust_name**
> AND c2.cust_contact = 'Jim Jones'


#### 自然联结
只能选择唯一的列，且每个内联结都是自然联结

#### 外联结
> SELECT c1.cust_id, Orders.order_num
> **FROM Customers**
> **LEFT OUTER JOIN Orders ON Customers.cust_id = Orders.cust_id**

#### 使用联结和连接头条件
* 一般使用内联结
* 应该总是给出联结条件
### 组合查询
> SELECT cust.name, cust.contact， cust_email
> FROM Customers
> WHERE cust_state IN ('IL', 'IN', 'MI')
> **UNION**
> SELECT cust.name, cust.contact， cust_email
> FROM Customers
> cust_name = 'Fun4All'

由前面两条SELECT语句组成，中间用UNION关键字分隔
UNION从查询结果集中自动去除了重复的行
使用UNION语句是只能使用一条ORDER BY语句在SELECT语句之后

### 插入数据
> **INSERT INTO** Customers(cust_id, cust_name)
> **VALUES**(100000006, 'Tony Land')

#### 从一个表复制到另外一个表
> **CREATE TABLE CustCopy** AS SELECT * FROM Customers
### 更新和删除数据
#### 更新
> **UPDATE** Customers
> **SET** cust_email = ‘kim@163.com’
> **WHERE** cust_id = 100000005

#### 删除
> **DELETE** FROM Customers
> **WHERE** cust_id = 100000005


### 创建和操纵表
#### 创建表
> **CREATE TABLE** OrderItems(
> order_num     INTEGER      NOT NULL,
> order_num     INTEGER      NOT NULL   DEFAULT 1 
> );


#### 更新表
> **ALTER TABLE** Vendors
> **ADD** vend_phone CHAR(20) 


### 使用视图
#### 创建视图
> **CREATE VIEW ProdectCustomers AS**
> SELECT vend_name, prod_name, prod_price
> FROM Vendors, Products
> WHERE Vendors.vend_id = Product.vend_id

#### 使用视图
> SELECT vend_name, prod_name
> **FROM ProdectCustomers**
> WHERE Vendors.vend_id = ‘RGAN01’
### 使用存储过程
### 管理事务处理
### 使用游标
### 高级SQL特性

## 数据库
### Q：会出现哪些并发一致性问题？
A：
* 丢失修改：一个事务对数据进行了修改，在事务提交之前，另一个事务对同一个数据进行了修改，覆盖了之前的修改；
* 脏读（Dirty Read）：一个事务读取了被另一个事务修改、但未提交（进行了回滚）的数据，造成两个事务得到的数据不一致；
* 不可重复读（Nonrepeatable Read）：在同一个事务中，某查询操作在一个时间读取某一行数据和之后一个时间读取该行数据，发现数据已经发生修改（针对update操作）；
* 幻读（Phantom Read）：当同一查询多次执行时，由于其它事务在这个数据范围内执行了插入操作，会导致每次返回不同的结果集（和不可重复读的区别：针对的是一个数据整体/范围；并且针对insert操作）

### Q：数据库的四种隔离级别？
A：未提交读（Read Uncommited）：在一个事务提交之前，它的执行结果对其它事务也是可见的。会导致脏读、不可重复读、幻读；
* 提交读（Read Commited）：一个事务只能看见已经提交的事务所作的改变。可避免脏读问题；
* 可重复读（Repeatable Read）：可以确保同一个事务在多次读取同样的数据时得到相同的结果。（MySQL的默认隔离级别）。可避免不可重复读；
* 可串行化（Serializable）：强制事务串行执行，使之不可能相互冲突，从而解决幻读问题。可能导致大量的超时现象和锁竞争，实际很少使用。

### Q：什么是乐观锁和悲观锁？
A：
* 悲观锁：认为数据随时会被修改，因此每次读取数据之前都会上锁，防止其它事务读取或修改数据；应用于数据更新比较频繁的场景；
* 乐观锁：操作数据时不会上锁，但是更新时会判断在此期间有没有别的事务更新这个数据，若被更新过，则失败重试；适用于读多写少的场景。乐观锁的实现方式有：
加一个版本号或者时间戳字段，每次数据更新时同时更新这个字段；
先读取想要更新的字段或者所有字段，更新的时候比较一下，只有字段没有变化才进行更新

### Q：常见的封锁类型？
A：
* 排它锁（Exclusive Lock）/ X锁：事务对数据加上X锁时，只允许此事务读取和修改此数据，并且其它事务不能对该数据加任何锁；
* 共享锁（Shared Lock）/ S锁：加了S锁后，该事务只能对数据进行读取而不能修改，并且其它事务只能加S锁，不能加X锁
* 意向锁（Intention Locks）：
    * 一个事务在获得某个数据行对象的 S 锁之前，必须先获得整个表的 IS 锁或更强的锁；
    * 一个事务在获得某个数据行对象的 X 锁之前，必须先获得整个表的 IX 锁；
IS/IX 锁之间都是兼容的；
    * 好处：如果一个事务想要对整个表加X锁，就需要先检测是否有其它事务对该表或者该表中的某一行加了锁，这种检测非常耗时。有了意向锁之后，只需要检测整个表是否存在IX/IS/X/S锁就行了


### Q：什么是三级封锁协议？
A：
* 一级封锁协议：事务在修改数据之前必须先对其加X锁，直到事务结束才释放。可以解决**丢失修改**问题（两个事务不能同时对一个数据加X锁，避免了修改被覆盖）；
* 二级封锁协议：在一级的基础上，事务在读取数据之前必须先加S锁，读完后释放。可以解决脏读问题（如果已经有事务在修改数据，就意味着已经加了X锁，此时想要读取数据的事务并不能加S锁，也就无法进行读取，**避免了读取脏数据**）；
* 三级封锁协议：在二级的基础上，事务在读取数据之前必须先加S锁，直到事务结束才能释放。可以解决**不可重复读**问题（避免了在事务结束前其它事务对数据加X锁进行修改，保证了事务期间数据不会被其它事务更新）


### Q：什么是两段锁协议？
A：事务必须**严格分为两个阶段对数据进行加锁和解锁**的操作，**第一阶段加锁**，**第二阶段解锁**。也就是说一个事务中一旦释放了锁，就不能再申请新锁了。

可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。事务遵循两段锁协议是保证可串行化调度的充分条件。

### Q：数据库的范式？
A：
* **第一范式**（1NF，Normal Form）：**属性不应该是可分的。**举例：如果将“电话”作为一个属性（一列），是不符合1NF的，因为电话这个属性可以分解为家庭电话和移动电话...如果将“移动电话”作为一个属性，就符合1NF；
* **第二范式** 2NF：**每个非主属性完全依赖于主属性集（候选键集）**；
**B完全依赖于A，就是说A中的所有属性唯一决定B，属性少了就不能唯一决定，属性多了则有冗余（叫依赖不叫完全依赖）**。举例：（学号，课程名）这个主属性集可以唯一决定成绩，但是对于学生姓名这个属性，（学号，课程名）这个属性集就是冗余的，所以学生姓名不完全依赖于（学号，课程名）这一属性集；
主属性集/候选码集：某一组属性能够唯一确定其它的属性（主键就是从候选键集中选的一个键），而其子集不能，这样的属性组中的属性就是主属性；不在候选码集中的属性成为非主属性；
可以通过分解来满足 2NF：将（学号，课程名，成绩）做成一张表；（学号，学生姓名）做成另一张表，避免大量的数据冗余； 满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；
* **第三范式** 3NF：**在 2NF 的基础上，非主属性不传递依赖于主属性**
传递依赖：如果C依赖于B，B依赖于A，那么C传递依赖于A；
3NF在2NF的基础上，消除了非主属性之间的依赖；比如一个表中，主属性有（学号），非主属性有（姓名，院系，院长名），可以看到院长名这个非主属性依赖于院系，传递依赖于学号。消除的办法是分解。 必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；

### Q：什么是存储过程？有哪些优缺点？
A：存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合。想要实现相应的功能时，只需要调用这个存储过程就行了（类似于函数，输入具有输出参数）。

**优点**：

* 预先编译，而不需要每次运行时编译，提高了数据库执行效率；
* 封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行SQL语句，可以减少网络通信量；
* 具有可复用性，减少了数据库开发的工作量；
* 安全性高，可以让没有权限的用户通过存储过程间接操作数据库；
* 更易于维护


**缺点**：

* 可移植性差，存储过程将应用程序绑定到了数据库上；
* 开发调试复杂：没有好的IDE；
* 修改复杂，需要重新编译，有时还需要更新程序中的代码以更新调用

### Q：Drop/Delete/Truncate的区别？
A：
* **Delete**用来**删除表的全部或者部分数据**，执行delete之后，用户需要提交之后才会执行，会触发表上的DELETE触发器（包含一个OLD的虚拟表，可以只读访问被删除的数据），DELETE之后表结构还在，删除很慢，一行一行地删，因为会记录日志，**可以利用日志还原数据**；
* **Truncate**删除表中的所有数据，这个操作不能回滚，也不会触发这个表上的触发器。操作比DELETE快很多（**直接把表drop掉，再创建一个新表，删除的数据不能找回**）。如果表中有自增（AUTO_INCREMENT）列，则重置为1；
* **Drop命令从数据库中删除表，所有的数据行，索引和约束都会被删除；不能回滚**，不会触发触发器；

### 数据库索引的实现原理（B+树）

#### 使用B树索引和哈希索引的比较
**哈希索引**能以 **O(1) 时间**进行查找，但是**只支持精确查找**，**无法用于部分查找和范围查找**，**无法用于排序与分组**；B树索引**支持大于小于等于查找，范围查找**。**哈希索引**遇到大量哈希值相等的情况后**查找效率会降低**。哈希索引不支持数据的排序。

### 使用索引的优点
* **大大加快了数据的检索速度；**
* **可以显著减少查询中分组和排序的时间；**
* 通过创建唯一性索引，可以**保证数据库表中每一行数据的唯一性**；
* 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）

**缺点：建立和维护索引耗费时间空间，更新索引很慢。**

### 哪些情况下索引会失效？
* **以“%(表示任意0个或多个字符)”开头的LIKE语句；**
* **OR语句前后没有同时使用索引；**
* 数据类型**出现隐式转化**（如varchar不加单引号的话可能会自动转换为int型）；
* 对于多列索引，必须满足 **最左匹配原则**/最左前缀原则 (最左优先，eg：多列索引col1、col2和col3，则 索引生效的情形包括 col1或col1，col2或col1，col2，col3)；
* 如果MySQL估计全表扫描比索引快，则不使用索引（比如非常小的表）

### 在哪些地方适合创建索引？
* **某列经常作为最大最小值；**
* **经常被查询的字段**；
* **经常用作表连接的字段**；
* 经常**出现在ORDER BY/GROUP BY/DISDINCT后面**的字段

### 创建索引时需要注意什么？
* 只应建立在小字段上，而不要对大文本或图片建立索引（一页存储的数据越多一次IO操作获取的数据越大效率越高）；
* 建立索引的字段应该非空，在MySQL中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替NULL；
* 选择数据密度大（唯一值占总数的百分比很大）的字段作索引

## 剑指46 47 48 52

## Java豆瓣爬虫 完成
