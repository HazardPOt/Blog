---
layout:     post
title:     Java基础（第二轮 2022.04.04 持续更新中）
description:     Project JOB
date:     2022-04-04
author:     POt
header-img:     img/post-bg-kuaidi.jpg
catalog: true
category: blog
tags:     
    -   
        -   

    -   

---

## Java的多态是什么

多态指的是**相同类型的变量在调用同一个方法时呈现出多种不同的行为特征**。而造成这一现象的原因在于

* 编译时类型，由**声明**变量时的类型决定
* 运行时类型，由**实际赋值给变量的对象的类型**决定

当一个变量的**两个类型不一致，就会出现多态**

例：

```java
//BaseClass是SubClass的父类
BaseClass a = new BaseClass();
BaseClass b = new SubClass();
a.baseMethod()//变量a调用baseMethod()方法，实际上会调用BaseClass的baseMethod()方法,会打印111
b.baseMethod()//变量b调用baseMethod方法，实际上会调用SubClass的重写baseMethod()方法，会打印222
Class BaseClass {
  void baseMethod() {
    System.out.println("111");
  }
}
Class SubClass {
  void baseMethod() {
    System.out.println("222");
  }
}

```

输出结果：
111
222

*BaseClass* a = new <u>BaseClass()</u>;

对于变量a而言，斜体的是编译时的类型，为*BaseClass*；下划线为实际赋值给变量的类型，为<u>BaseClass</u>，所以调用baseMathod()会执行BaseClass#baseMathod方法，打印出111

对于变量b而言，编译时的方法为*BaseClass*；实际赋给变量的类型为<u>SubClass()</u>，而SubClass重写了父类BaseClass#baseMathod()，所以调用baseMethod()方法会调用SubClass#baseMethod()，从而打印出222.

（PS：如果直接对b调用只有SubClass有的方法，编译时会报错，但是可以通过反射进行调用。）

a和b编译类型相同，却展现出不同的行为特征，这就是多态。

## Java中变量，代码块，构造器之间执行顺序是怎么样的？

Java初始化顺序为：

* 先初始化静态部分，再初始化动态部分
* 先初始化父类部分，再初始化子类部分
* 先初始化变量，再初始化代码块和构造器

所以依照这个规则可以总结出总体的顺序为：

1. 父类的静态成员变量（如果是第一次加载类）
2. 父类的静态静态代码块（如果是第一次加载类）
3. 子类的静态成员变量（如果是第一次加载类）
4. 子类的静态代码块（如果是第一次加载类）
5. 父类的普通成员变量
6. 父类的动态代码块
7. 父类的构造器方法
8. 子类的普通成员变量
9. 子类的动态代码块
10. 子类的构造器方法

### Q：什么是动态代码快，什么是静态代码块？

```
class Test{
		{
		// write dynamic code here
		}
		
		static{
		// write static code here
		}
}
```

## final关键字有哪些作用

### 修饰类

如果是类，那么说明类不可被继承

### 修饰方法

final修饰方法时

* 方法不可被子类重写
* 可以让方法转换为内联调用，提升效率

### 修饰变量

一旦这个变量初始化后，这个变量不可以修改。

## Integer类会进行缓存吗

```java
Intger a =  new Integer(127);
Intger b = Interger.valueOf(127);
Intger c = Interger.valueOf(127);
Intger d = Interger.valueOf(128);
Intger e = Interger.valueOf(128);
System.out.println(a == b); //输出false
System.out.println(b == c); //输出true
System.out.println(d == e); //输出false
```

