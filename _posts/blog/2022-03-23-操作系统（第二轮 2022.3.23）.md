---
layout:     post
title:     操作系统（第二轮 2022.3.23）
description:     Project JOB
date:     2022-03-23
author:     POt
header-img:     img/post-bg-kuaidi.jpg
catalog: true
category: blog
tags:     
    -   
        -   

    -   

---

## 内核态和用户态

### 内核态和用户态的区别

**最简单的运行程序的方式是直接执行，直接执行会有以下问题**

* **如何限制代码行为**
* **运行程序时如何切换到另一个程序，进程调度时OS的权限。**

所以引入内核态和用户态两种行为

内核态的权限较高，用户态的权限较低

用户态只能访问部分内存，不能进行IO操作，不能占有CPU资源

内核态的可以访问全部内存，可以进行IO操作，可以完全占有CPU资源

### 什么时候会陷入内核态

1. 系统调用：**是用户进程主动发起的操作，发起系统调用，陷入内核，由OS执行系统调用，再返回给进程**
2. 中断 **中断和异常是被动的，无法预测发生时机，IO中断、外部信号中断等**
3. 异常 **中断和异常都会通过中断向量表来找到相应的处理程序来进行处理**

### C访问空指针会不会陷入内核态

会

**访问指针相当于访问一个虚拟地址，硬件会将虚拟地址映射到真实的物理内存中，如果映射失败，会抛出一个错误异常，此时会从用户态转为内核态进行处理。**

## 陷阱、中断、异常、信号

### 前言，为什么会产生陷阱、中断、异常、信号（异常控制流）

**程序是由一条一条指令构成的，顺序执行指令叫做控制流。在执行的过程中，系统也会发生一些异常情况。处理这些异常的时候，会打断进程的控制流，转而执行相应的处理程序，执行完毕在返回，叫异常控制流。**

### 陷阱、中断、异常、信号的产生来源

陷阱**是有意造成的异常**，用户自己设定的，目的是执行系统调用，**进行系统调用时，会通过系统调用唯一的整数号，对应跳转表中的偏移量，从而执行相应的系统调用**     *（软中断）* 

中断是不可预知的，由外部设备所造成的，由于中断独立于当前的程序，**中断是异步事件**。**在中断时，操作系统会根据中断号，在中断描述表中查找并执行相应的中断处理程序，当处理程序返回后，进程继续执行下一条指令，就好像没发生过一样。**

异常是程序自己抛出的，是一种错误情况，**可能被处理程序修正，也可能直接终止应用程序，异常是同步的。**

信号一种更高级的异常形式，也会改变进程的控制流。

![](https://s2.loli.net/2022/03/23/2Ven7urIWJc5y3A.png)

### 陷阱、中断、异常、信号的处理流程

### 常见的陷阱、中断、异常、信号有哪些

### Ctrl + C、Ctrl + Z、kill -9的原理

## 进程与线程

### 进程与线程的区别

1. 进程是系统分配资源的基本单位，线程是CPU分配资源的基本单位

2. 线程依赖于进程存在，一个进程可以拥有n个线程

3. 线程通信比较方便**（通过共享内存）**，而进程之间需要用IPC进行通讯

4. 多进程的程序相对稳定，一个进程崩溃不会影响整个程序。多线程程序一个线程崩溃，程序均无法运行

5. 进程耗费系统资源，线程几乎不耗费系统资源

6. **进程切换开销很大，线程切换开销很小**

   | 进程     | 线程                                            |                                                              |
   | -------- | ----------------------------------------------- | ------------------------------------------------------------ |
   | 资源     | 进程是一个**拥有资源**和**执行任务**的单元体。  | 线程是一个**执行任务**的单元体，**不拥有资源**，线程之间**共享地址空间** |
   | 切换开销 | 开销很大                                        | 开销很小                                                     |
   | 通信     | [IPC](https://imageslr.com/2020/02/26/ipc.html) | 共享内存                                                     |
   | 健壮性   | 健壮，多个进程之间不会互相干扰                  | 不健壮，一个线程出错会终止整个进程                           |

### 为什么需要线程

**进程切换是一个开销很大的操作，主要开销包括：**

1. **上下文切换：保存和恢复相关寄存器的内容**
2. **与进程相关的数据结构更改：存储页表、文件描述符、队列等**

**所以如果我们只切换必须的，和处理机相关的信息就可以减少开销，由此引入线程**

线程是CPU分配资源的基本单位，进程依托于线程而存在

### 线程上下文切换过程

将上下文保存到TCB（Thread Control Block）中，同时恢复另一个进程的上下文

线程只需要切换和处理机相关的上下文就可以了，**开销少，提升效率**

### 线程的优缺点

* 线程的优点：**开销少，提升效率**，通信较为方便，可相互共享进程的代码、变量、文件描述符等
* 线程的缺点：多线程程序中，一个线程出错，就会结束整个进程。**同一进程中的多个线程共享内存，会有并发以及安全问题。**

### 同一进程中线程共享的与独占的资源

共享：

* **内存空间**
  * 代码
  * 公共数据
  * 堆
* **文件描述符**
* **信号处理器**
* **进程ID**
* ...

独享资源以及为什么要独占：

* **线程ID**：在本进程中唯一，进程用来标识此线程
* 一组寄存器的值
* **栈**：每个线程中的函数调用时独立的，因此需要有独立的栈
* **错误返回码**：系统调用或库函数发生错误时，会设置全局变量`errno`，各个线程的错误返回码应该是独立的
* 信号屏蔽码：每个线程所感兴趣的信号不同，所以线程的信号屏蔽码应该由线程自己管理

### 线程的实现方式

线程也像进程一样有多个状态：运行态、就绪态、阻塞态

**线程实现的方式有三种：**

* **在内核中实现**
* **在用户空间中实现**
* **混合方式实现**

### 线程池介绍、应用背景

## 进程的调度

### 进程的状态

三态：就绪态、运行态、阻塞态

* 就绪态：该进程除了CPU资源外其余资源均已准备完毕，等待分配CPU资源
* 运行态：拥有CPU资源，并且正在运行程序
* 阻塞态：该进程在等待某种条件，在满足条件前无法运行

五态：新建态、就绪态、运行态、阻塞态、终止态

七态：

- **挂起就绪状态：进程在外存中，但是只要被载入内存就可以执行**

- **挂起阻塞状态：进程在外存中并等待一个事件，即使被载入内存（激活）也无法运行**

  ![](https://imageslr.com/media/15941900183711.jpg)

### 调度算法

**调度算法的分类：**

* 按照CPU的分配方式：**非抢占式、抢占式**
* 按照系统的分时方式：**批处理系统、可交互系统**

### 批处理系统、可交互系统的调度算法

调度算法的目标：

* **吞吐量**
* **周转时间**
* **CPU利用率**

批处理系统：

1. 先来先服务：顾名思义，谁先来谁先服务，可能会有饥饿现象；**对短作业不友好**；**对IO密集型进程不利**；**非抢占式**
2. 最短作业优先：哪个进程运行时间最短，就先进行服务。对长进程不友好，可能会有饥饿现象
3. 最短剩余时间优先：哪个剩余时间最少就先进行服务，**对长作业不公平，导致饥饿问题，同“最短时间优先”**
4. 最高响应比算法：**响应比 = 等待时间 / 运行时间**，**同时考虑了等待时间和执行时间，及考虑短作业也考虑长作业**

可交互式系统

1. 时间片轮转：按照先来先服务排成一个循环队列。定义一个时间片，给每个进程都分配一个时间片大小的运行时间，如果在一个时间片内没有运行完，则排到队尾。**没有饥饿问题**。**时间片小，IO大**，**时间片大，响应时间太长，对短作业不利**
2. 优先级**调度**算法：（**同级别时间片轮转**）根据作业时间给进程分级，每个级别拥有不同的运行时间，级别可根据运行情况和时间动态调整
3. **多级反馈队列**：**优先级高的队列先执行，优先级越高，时间片越短。**

### 僵尸进程、孤儿进程、守护进程

前提：当一个进程*由于某些原因被终止时，内核并不是立即把它从系统中清除。进程会保持在一种“已终止”的状态中，直到被它的父进程回收。*当父进程回收已终止的子进程时，内核会抛弃已终止的进程，此时该进程就不存在了。

僵尸进程：（停止运行）**是指终止但未回收的进程**，如果子进程退出，而父进程没有调用`wait()`，或者`waitpid()`来回收，那么就会产生僵尸进程。僵尸进程是一个已经死亡的进程，但是其进程描述符仍然保存在系统的进程表中

孤儿进程：父进程在子进程结束前自行结束，这时候子进程变成了孤儿进程，会通过init()函数对孤儿进程进行托管和转交

**守护进程：在后台执行的电脑程序。此类程序会被以进程的形式初始化**

## 线程和进程的通信方式

### 信号、管道、信号量、共享内存、消息队列

#### 信号

信号是Linux系统**响应某些条件而产生的一个事件**，**由操作系统事先定义**，接收到该信号的进程可以采取自定义行为。

信号来源分为硬件来源和软件来源

* 硬件来源：如按下Ctrl + C，除0，非法内存访问等等
* 软件来源：kill命令...

**一般的信号都是由一个错误产生的，除0**

进程如何发送信号？

* **操作系统提供发送信号的系统调用**
* 该系统调用会将信号放到目标进程的信号队列中

如何接受信号？

* 每个进程有一个信号队列，存放其他进程发给它、等待它处理的信号

用户对信号的处理：处理信号、忽略信号、不处理也不忽略

#### 管道

* 匿名管道

  **半双工**、如果要同时进行通信要走两条管道。**只能用于亲缘进程之间的传输**，**管道适合传输大量信息**

* 命名管道（FIFO）

  可用于没有亲缘的进程间，`mknode()` `mkfifo()`

#### 信号量

信号量是一种特殊的变量，**对它的操作都是原子的**。PV操作，是保证同步互斥的，同一时间只能有一个进程访问临界资源。只有0和1

#### 共享内存

**不同进程可以将同一段共享内存映射到自己的地址空间，然后像访问正常内存一样访问它，优点是简单且高效，但是会存在并发问题。**

#### 消息队列

**消息队列是一个消息的链表，保存在内核，每一个消息都是一个数据块**

#### 套接字（Socket）

不同计算机的进程之间可以使用Socket通信，内含主机地址和端口号

### 各种通信方式的原理、适用场景

## 锁的类型与实现

### 了解哪些类型的锁

**互斥锁、读写锁、自旋锁、条件锁**

### 互斥锁的实现方式

### 读写锁的实现方式

## 进程的同步与互斥

### 临界资源和临界区的概念

临界资源：多个进程同一时间只能有一个进程访问的资源。

临界区：多个进程同一时间只能有一个进程访问临界资源的代码块。

### 同步和互斥的概念

同步：多个进程为了合作而使进程按照一定顺序进行运行，一个进程运行时，其余进程等待

互斥：同一时间只能有一个进程进入临界区

### 临界区的管理规则

* **同一时间只能有一个进程访问临界区**
* **不应该对CPU的速度和数量做任何假设**
* **临界区外运行的进程不得阻塞其他进程**
* **不得使进程无限等待进入临界区**

### 信号量和PV操作

信号量：一般成对出现，一个信号量表示**缓冲区**已经使用了多少空间，另一个信号量表示**缓冲区**还有多少空间剩余

P操作，信号量-1

V操作，信号量+1

### 原子操作的原理

### volatile解决什么问题

### 一些常见的并发问题

#### 生产者消费者问题

#### 读者写者问题

#### 浴室洗澡问题

#### 哲学家就餐问题

## 死锁的预防、检测、避免、解除

### 死锁产生的四个必要条件

1. 互斥
2. 占有等待
3. 非抢占
4. 循环等待

### 如何预防、检测、避免、解除死锁

预防：破坏产生死锁的四个条件（占有等待：预先分配；非抢占：允许强行抢占；）

检测：画出资源分配图， 检测是否存在环路，如果有环路要对其进行化简

避免：允许系统存在四个必要条件，但每当进程提出资源申请时，要判断是否会产生死锁

解除：


## 物理内存管理

###  不同的内存分配技术及其优缺点
#### 引进内存分配技术的原因：
内部碎片和外部碎片：

**内部碎片是固定分区法产生的**，指被占用分区上未被利用的空间，由于该分区被占用，因此无法被分配使用
**外部碎片是动态分区法产生的**，*指被占用分区之间的小空间*，虽然可以被使用，但是由于太小而无法被分配


* 固定分区法（等长、不等长）

    **每个分区大小相同**，在系统启动时分配好，系统运行期间保持不变；每次给进程分配一整块区域，**因此进程的大小必须 ≤ 分区的大小**
    * 优点：系统需要维护的管理信息非常少
    * 缺点：不同进程需要的空间不同，内部碎片多，浪费空间

* 动态分区法

    **在系统运行中，根据每个进程需要的空间大小确定分区大小**
    
    * 并发执行的程序数量不受限制，只取决于是否有大小合适的内存块可以分配
    * 管理空闲快的复杂度增加；分配算法的时间开销增加，可能需要遍历多次才能找到合适的内存块

* 页式内存管理

    把固定分区面积缩小，一个进程可使用多个分区；进程被分割成若干块，装入内存中的几个分区中，物理上无需相连，逻辑上通过页表关联。这是一种内存的不连续分配方法（**进程和内存被分隔成一样的大小**）
    
    * 优点：不存在任何外部碎片，只在每个进程的最后一个页框中存在内部碎片
 
* 段式内存管理

    按照程序代码段将程序分割为n段，每个段独立载入到内存的不同区间中。
    
    * 优点：分页不考虑每个页中内容的意义，而分段是按照逻辑关系划分
    * 缺点：每个段必须连续、全部加载到内存中

* 段页式内存管理

    把分段和分页两种方式结合，先把程序按照逻辑意义分成段，然后每个段再分成固定大小的页
![](https://s2.loli.net/2022/03/20/N7wedIGSDlKh6PM.jpg)

### 不同的动态分区放置算法及其优缺点

* 最佳适应算法

    * 检查所有空闲分区，选择和新进程申请内存大小最接近的空闲分区
    * 优点：该算法保留大的空闲区
    * 缺点：检查所有空闲分区需要时间、外部碎片多、可以采用内存紧凑的方法，将被使用的分区都移动到一起，减少外部碎片。但是移动内存中的代码和数据也需要很多时间

## 虚拟内存管理
### 虚拟内存的思想 / 实现方法

### 暂时不在内存中的数据存在哪里？
### 虚拟地址的映射
### TLB的原理
### 虚拟地址到物理地址的翻译过程
### 缺页中断的处理
### 不同的淘汰算法及其适用场景
