---
layout:     post
title:     Android 项目中所用到的技术总结（2022.04.07 持续更新中）
description:     Project JOB
date:     2022-04-07
author:     POt
header-img:     img/post-bg-kuaidi.jpg
catalog: true
category: blog
tags:     
    -   
        -   

    -   

---

# 

## Activity的启动模式

### Standard（标准模式）

每启动一次Activity，就会创建一个新的Activity实例并置于栈顶，谁启动了这个Activity，那么这个Activity就会运行在启动它的那个Activity所在的栈中

### SingleTop（栈顶复用模式）

每次检查如果新Activity在栈顶那么就复用，如果不在栈顶则新建一个Activity

适用于：浏览器书签，消息聊天界面

### SingleTask（栈内复用模式）

会检查栈内是否有新Activity，如果有就将前面的Activity出栈，直到新Activity在栈顶为止

适用于：某个界面作为首页面的时候

### SingleInstance（单实例模式）

加强版SingleTask，该Activity只能单独位于一个任务栈且该栈只有它一个

适用于：闹钟闹铃，浏览器BrowerActivity占内存

## Activity生命周期

启动： onCreate （用户不可见） -> onStart （用户可见但不在前台在后台，无法与用户交互） -> onResume (用户可见，在前台并获得焦点) 点击Home回主界面（Activity不可见） -> onPause -> onStop 再次回到原Activity -> onRestart -> onStart -> onResume 退出Activity -> onPause -> onStop -> onDestory

* onCreate：**创建，用于初始化工作**，比如调用setContentView加载界面布局资源，初始化Activity等。
* onDestroy：**表明即将被销毁**，这是Activity中最后一个回调，长用作回收工作，资源释放
* onStart：**启动，此时Activity可见，但不在前台**，还处于后台，无法与用户进行交互
* onStop：**即将停止，可以做一些稍微重量级的回收回收工作**，比如注销广播接收器、关闭网络连接等，同样不能太耗时
* onResume：获得焦点，**此时Activity可见在前台并开始活动**，这是与onStart的区别所在
* onPause：**正在停止，可以做存储数据、停止动画等工作**，但是不能太耗时，因为会影响到新Activity的显示。**onPause必须先执行完，新Activity的onResume才会执行**
* onRestart：重新启动，一般情况下，当前Acitivty 从不可见重新变为可见时，OnRestart 就会被调用

## MVC、MVP与MVVM

### MVC（Model View Controller）

MVC解决的是控制层，数据处理层、界面交互进行解耦

* Model：负责**数据的处理和加载**
* View：负责**界面的展示**
* Controller：负责逻辑**控制**

MVC通过Controller的控制操作Model层的数据，返回给View进行展示

![](https://camo.githubusercontent.com/320b4ec006528281976a67a592a2b93d299d236876b70d862fa5b772a5cca5e7/68747470733a2f2f706963312e7a68696d672e636f6d2f38302f76322d39643162386232303662633362373832626235646262313033626262373365345f373230772e6a7067)

#### MVC的优点

* 结构清晰
* 降低耦合（耦合：是指一程序中，模块及模块之间信息或参数依赖的程度）

### MVP（Model View Presenter）

MVP要解决的问题与MVC大同小异，即**控制逻辑，数据处理逻辑以及界面交互解耦**，同时，将MVC中的View和Model解耦。

* Model模型：负责数据的存储和加载
* View模型：负责界面的展示
* Presenter控制器：负责逻辑控制

MVP和MVC最大的不同就是**View层和Model层不互相持有**，**都通过Presenter交互**。View产生事件通知Presenter，Presenter中进行逻辑处理后通知Model更新数据，Model更新数据后通知数据给Presenter，Presenter再通知View更新界面。示意图如下：

![](https://camo.githubusercontent.com/5fc970a6a08b5e07cca27d4e54f8f4adee5039f76d7a048087f5ee7f38650961/68747470733a2f2f706963312e7a68696d672e636f6d2f38302f76322d63646663366336306538626531613362386361613766653036393761326530635f373230772e6a7067)

Model层和View层全靠Presenter层进行交互，二者不直接交互

#### MVP的优点：

* 结构清晰
* 模块间充分解耦
* 有利于组件的重用

### MVVM（Model View ViewModel）

MVVM要解决的问题是将控制逻辑、数据处理逻辑以及界面交互进行**解耦**，并且能将**MVC中的View和Model解耦**，还可以把**MVP中的Presenter和View也解耦**。

MVVM架构中，将逻辑、数据、界面的处理分为三部分，即模型（Model）、视图（View）以及逻辑（ViewModel）。各个部分的功能如下：

- Model模型：负责数据的加载和存储
- View视图：负责界面的展示
- ViewModel控制器：负责逻辑控制

在 MVP 中，就是 View 和 Model 不相互持有，都通过 Presenter 做中转。这样可以使 View 和 Model 解耦。而在**MVVM中解耦做的更彻底**，**ViewModel也不会持有View**，其中ViewModel中的改动会**自动反馈给View进行界面更新**，而View的事件也会自动反馈给ViewModel。

![](https://camo.githubusercontent.com/6cb578f5655bee6e100a210cb63432b9f2f1103ec76ca7e8297bf8fdf4f52ac8/68747470733a2f2f706963342e7a68696d672e636f6d2f38302f76322d66366637633065353366343265376433323931633737383462316232643135375f373230772e6a7067)

## SharePreferences

SharedPreferences是Android中**轻量级的数据存储方式**，适用于保存简单的数据类型。其内部是以**xml**结构**保存在/data/data/{包名}/shared_prefs**文件夹下的。数据以键值对的形式保存，如下：

```html
<map>
    <float name="isFloat" value="1.5" />
    <string name="isString">Android</string>
    <int name="isInt" value="1" />
    <long name="isLong" value="1000" />
    <boolean name="isBoolean" value="true" />
    <set name="isStringSet">
        <string>element 1</string>
        <string>element 2</string>
        <string>element 3</string>
    </set>
</map>
```

```java
// 通过Context获取SharedPreferencesImpl实例
SharedPreferences sp = Context.getSharedPreferences("my_sp", Context.MODE_PRIVATE);
// 通过SP获取EditorImpl实例
SharedPreferences.Editor edit = sp.edit();
// 存入key为value，值为text的数据。
edit.putString("value","test");
// 提交
edit.apply(); // 或者edit.commit();
// 从SP中读取value对应的值
sp.getString("value","");
```

和map一样，也是<key, value>的形式

### 获取SharedPreferences

* 根据name从缓存中取出SP文件，返回
* 可以看到ContextImpl的getSharedPreferences最终获取到的是SharedPreferencesImpl实例对象。

### 从SP中读取数据

* 这里会调用awaitLoadedLocked方法看是否已加载了xml文件
* 如果没加载则阻塞主线程并加载xml文件
  awaitLoadedLocked();
* 加载完成后才会从内从中读取key对应的value

getString中使用synchronized对代码块进行了加锁，并且首先会调用awaitLoadedLocked方法去加载xml文件。

## ArrayMap

在移动设备端内存资源很珍贵，HashMap为实现快速查询带来了很大内存的浪费。

ArrayMap是Android专门针对内存优化而设计的，用于取代Java API中的HashMap数据结构。为了更进一步优化key是int类型的Map，Android再次提供效率更高的数据结构SparseArray，可避免自动装箱过程。对于key为其他类型则可使用ArrayMap。**HashMap的查找和插入时间复杂度为O(1)的代价是牺牲大量的内存来实现的**，而SparseArray和ArrayMap性能略逊于HashMap，但更节省内存。

#### 数据结构

- ArrayMap和SparseArray采用的都是**两个数组**，Android专门针对内存优化而设计的
- HashMap采用的是数据+链表+红黑树

mHashes是一个**记录所有key的hashcode值**组成的数组，是从小到大的排序方式；
mArray是一个**记录着key-value键值对**所组成的数组，是mHashes大小的2倍；

![](http://gityuan.com/images/arraymap/arrayMap.jpg)

#### 内存优化

- ArrayMap比HashMap更节省内存，综合性能方面在数据量不大的情况下，推荐使用ArrayMap；
- Hash需要**创建一个额外对象来保存每一个放入map的entry**，且**容量的利用率比ArrayMap低**，整体更消耗内存
- **SparseArray比ArrayMap节省1/3的内存**，但**SparseArray只能用于key为int类型的Map**，所以int类型的Map数据推荐使用SparseArray；

#### 缓存机制

- **ArrayMap针对容量为4和8的对象进行缓存**，可避免频繁创建对象而分配内存与GC操作，这两个缓存池大小的上限为10个，防止缓存池无限增大；
- HashMap**没有缓存机制**
- SparseArray有延迟回收机制，提供删除效率，同时减少数组成员来回拷贝的次数

### 扩容机制

- ArrayMap是在容量满的时机触发容量**扩大至原来的1.5倍**（**和ArrayList是一样的**），**在容量不足1/3时触发内存收缩至原来的0.5倍**，更节省的内存扩容机制
- **HashMap是在容量的0.75倍时触发容量扩大至原来的2倍**，且没有内存收缩机制。HashMap扩容过程有hash重建，相对耗时。所以能大致知道数据量，可指定创建指定容量的对象，能减少性能浪费。

#### 并发问题

- ArrayMap是非线程安全的类，大量方法中通过对mSize判断是否发生并发，来决定抛出异常。但没有覆盖到所有并发场景，比如大小没有改变而成员内容改变的情况就没有覆盖
- HashMap是在每次增加、删除、清空操作的过程将modCount加1，在关键方法内进入时记录当前mCount，执行完核心逻辑后，再检测mCount是否被其他线程修改，来决定抛出异常。这一点的处理比ArrayMap更有全面。

