---
layout:     post
title:     Android 项目中所用到的技术总结（2022.04.07 持续更新中）
description:     Project JOB
date:     2022-04-07
author:     POt
header-img:     img/post-bg-kuaidi.jpg
catalog: true
category: blog
tags:     
    -   
        -   

    -   

---

# 

## Activity的启动模式

### Standard（标准模式）

每启动一次Activity，就会创建一个新的Activity实例并置于栈顶，谁启动了这个Activity，那么这个Activity就会运行在启动它的那个Activity所在的栈中

### SingleTop（栈顶复用模式）

每次检查如果新Activity在栈顶那么就复用，如果不在栈顶则新建一个Activity

适用于：浏览器书签，消息聊天界面

### SingleTask（栈内复用模式）

会检查栈内是否有新Activity，如果有就将前面的Activity出栈，直到新Activity在栈顶为止

适用于：某个界面作为首页面的时候

### SingleInstance（单实例模式）

加强版SingleTask，该Activity只能单独位于一个任务栈且该栈只有它一个

适用于：闹钟闹铃，浏览器BrowerActivity占内存

## Activity生命周期

启动： onCreate （用户不可见） -> onStart （用户可见但不在前台在后台，无法与用户交互） -> onResume (用户可见，在前台并获得焦点) 点击Home回主界面（Activity不可见） -> onPause -> onStop 再次回到原Activity -> onRestart -> onStart -> onResume 退出Activity -> onPause -> onStop -> onDestory

* onCreate：**创建，用于初始化工作**，比如调用setContentView加载界面布局资源，初始化Activity等。
* onDestroy：**表明即将被销毁**，这是Activity中最后一个回调，长用作回收工作，资源释放
* onStart：**启动，此时Activity可见，但不在前台**，还处于后台，无法与用户进行交互
* onStop：**即将停止，可以做一些稍微重量级的回收回收工作**，比如注销广播接收器、关闭网络连接等，同样不能太耗时
* onResume：获得焦点，**此时Activity可见在前台并开始活动**，这是与onStart的区别所在
* onPause：**正在停止，可以做存储数据、停止动画等工作**，但是不能太耗时，因为会影响到新Activity的显示。**onPause必须先执行完，新Activity的onResume才会执行**
* onRestart：重新启动，一般情况下，当前Acitivty 从不可见重新变为可见时，OnRestart 就会被调用

## MVC、MVP与MVVM

### MVC（Model View Controller）

MVC解决的是控制层，数据处理层、界面交互进行解耦

* Model：负责**数据的处理和加载**
* View：负责**界面的展示**
* Controller：负责逻辑**控制**

MVC通过Controller的控制操作Model层的数据，返回给View进行展示

![](https://camo.githubusercontent.com/320b4ec006528281976a67a592a2b93d299d236876b70d862fa5b772a5cca5e7/68747470733a2f2f706963312e7a68696d672e636f6d2f38302f76322d39643162386232303662633362373832626235646262313033626262373365345f373230772e6a7067)

#### MVC的优点

* 结构清晰
* 降低耦合（耦合：是指一程序中，模块及模块之间信息或参数依赖的程度）

### MVP（Model View Presenter）

MVP要解决的问题与MVC大同小异，即**控制逻辑，数据处理逻辑以及界面交互解耦**，同时，将MVC中的View和Model解耦。

* Model模型：负责数据的存储和加载
* View模型：负责界面的展示
* Presenter控制器：负责逻辑控制

MVP和MVC最大的不同就是**View层和Model层不互相持有**，**都通过Presenter交互**。View产生事件通知Presenter，Presenter中进行逻辑处理后通知Model更新数据，Model更新数据后通知数据给Presenter，Presenter再通知View更新界面。示意图如下：

![](https://camo.githubusercontent.com/5fc970a6a08b5e07cca27d4e54f8f4adee5039f76d7a048087f5ee7f38650961/68747470733a2f2f706963312e7a68696d672e636f6d2f38302f76322d63646663366336306538626531613362386361613766653036393761326530635f373230772e6a7067)

Model层和View层全靠Presenter层进行交互，二者不直接交互

#### MVP的优点：

* 结构清晰
* 模块间充分解耦
* 有利于组件的重用

### MVVM（Model View ViewModel）

MVVM要解决的问题是将控制逻辑、数据处理逻辑以及界面交互进行**解耦**，并且能将**MVC中的View和Model解耦**，还可以把**MVP中的Presenter和View也解耦**。

MVVM架构中，将逻辑、数据、界面的处理分为三部分，即模型（Model）、视图（View）以及逻辑（ViewModel）。各个部分的功能如下：

- Model模型：负责数据的加载和存储
- View视图：负责界面的展示
- ViewModel控制器：负责逻辑控制

在 MVP 中，就是 View 和 Model 不相互持有，都通过 Presenter 做中转。这样可以使 View 和 Model 解耦。而在**MVVM中解耦做的更彻底**，**ViewModel也不会持有View**，其中ViewModel中的改动会**自动反馈给View进行界面更新**，而View的事件也会自动反馈给ViewModel。

![](https://camo.githubusercontent.com/6cb578f5655bee6e100a210cb63432b9f2f1103ec76ca7e8297bf8fdf4f52ac8/68747470733a2f2f706963342e7a68696d672e636f6d2f38302f76322d66366637633065353366343265376433323931633737383462316232643135375f373230772e6a7067)

## SharePreferences

SharedPreferences是Android中**轻量级的数据存储方式**，适用于保存简单的数据类型。其内部是以**xml**结构**保存在/data/data/{包名}/shared_prefs**文件夹下的。数据以键值对的形式保存，如下：

```html
<map>
    <float name="isFloat" value="1.5" />
    <string name="isString">Android</string>
    <int name="isInt" value="1" />
    <long name="isLong" value="1000" />
    <boolean name="isBoolean" value="true" />
    <set name="isStringSet">
        <string>element 1</string>
        <string>element 2</string>
        <string>element 3</string>
    </set>
</map>
```

```java
// 通过Context获取SharedPreferencesImpl实例
SharedPreferences sp = Context.getSharedPreferences("my_sp", Context.MODE_PRIVATE);
// 通过SP获取EditorImpl实例
SharedPreferences.Editor edit = sp.edit();
// 存入key为value，值为text的数据。
edit.putString("value","test");
// 提交
edit.apply(); // 或者edit.commit();
// 从SP中读取value对应的值
sp.getString("value","");
```

和map一样，也是<key, value>的形式

### 获取SharedPreferences

* 根据name从缓存中取出SP文件，返回
* 可以看到ContextImpl的getSharedPreferences最终获取到的是SharedPreferencesImpl实例对象。

### 从SP中读取数据

* 这里会调用awaitLoadedLocked方法看是否已加载了xml文件
* 如果没加载则阻塞主线程并加载xml文件
  awaitLoadedLocked();
* 加载完成后才会从内从中读取key对应的value

getString中使用synchronized对代码块进行了加锁，并且首先会调用awaitLoadedLocked方法去加载xml文件。

## ArrayMap

在移动设备端内存资源很珍贵，HashMap为实现快速查询带来了很大内存的浪费。

ArrayMap是Android专门针对内存优化而设计的，用于取代Java API中的HashMap数据结构。为了更进一步优化key是int类型的Map，Android再次提供效率更高的数据结构SparseArray，可避免自动装箱过程。对于key为其他类型则可使用ArrayMap。**HashMap的查找和插入时间复杂度为O(1)的代价是牺牲大量的内存来实现的**，而SparseArray和ArrayMap性能略逊于HashMap，但更节省内存。

#### 数据结构

- ArrayMap和SparseArray采用的都是**两个数组**，Android专门针对内存优化而设计的
- HashMap采用的是数据+链表+红黑树

mHashes是一个**记录所有key的hashcode值**组成的数组，是从小到大的排序方式；
mArray是一个**记录着key-value键值对**所组成的数组，是mHashes大小的2倍；

![](http://gityuan.com/images/arraymap/arrayMap.jpg)

#### 内存优化

- ArrayMap比HashMap更节省内存，综合性能方面在数据量不大的情况下，推荐使用ArrayMap；
- Hash需要**创建一个额外对象来保存每一个放入map的entry**，且**容量的利用率比ArrayMap低**，整体更消耗内存
- **SparseArray比ArrayMap节省1/3的内存**，但**SparseArray只能用于key为int类型的Map**，所以int类型的Map数据推荐使用SparseArray；

#### 缓存机制

- **ArrayMap针对容量为4和8的对象进行缓存**，可避免频繁创建对象而分配内存与GC操作，这两个缓存池大小的上限为10个，防止缓存池无限增大；
- HashMap**没有缓存机制**
- SparseArray有延迟回收机制，提供删除效率，同时减少数组成员来回拷贝的次数

### 扩容机制

- ArrayMap是在容量满的时机触发容量**扩大至原来的1.5倍**（**和ArrayList是一样的**），**在容量不足1/3时触发内存收缩至原来的0.5倍**，更节省的内存扩容机制
- **HashMap是在容量的0.75倍时触发容量扩大至原来的2倍**，且没有内存收缩机制。HashMap扩容过程有hash重建，相对耗时。所以能大致知道数据量，可指定创建指定容量的对象，能减少性能浪费。

#### 并发问题

- ArrayMap是非线程安全的类，大量方法中通过对mSize判断是否发生并发，来决定抛出异常。但没有覆盖到所有并发场景，比如大小没有改变而成员内容改变的情况就没有覆盖
- HashMap是在每次增加、删除、清空操作的过程将modCount加1，在关键方法内进入时记录当前mCount，执行完核心逻辑后，再检测mCount是否被其他线程修改，来决定抛出异常。这一点的处理比ArrayMap更有全面。

## OKHTTP

[[OKHttp 源码分析](https://hazardpot.github.io/OKHttp源码分析)](https://hazardpot.github.io/OKHttp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90)

## JSON解析

### JSON详解

Json是一种轻量级的数据交换格式，采用一种“键：值”对的文本格式来存储和表示数据，在系统交换数据过程中常常被使用，是一种理想的数据交换语言。在使用Java做Web开发时，不可避免的会遇到Json的使用。

#### JSON对象

1. 数据在花括号中

2. 数据以"键：值"对的形式出现（其中键多以字符串形式出现，值可取字符串，数值，甚至其他json对象）

3. 每两个"键：值"对以逗号分隔（最后一个"键：值"对省略逗号）

```json
{
	"ID": 1001,
	"name": "张三",
	"age": 24
}
```



#### JSON对象数组

1. 数据在方括号中（可理解为数组）

2. 方括号中每个数据以json对象形式出现

3. 每两个数据以逗号分隔（最后一个无需逗号）

```json
[
	{"ID": 1001, "name": "张三", "age": 24},
	{"ID": 1002, "name": "李四", "age": 25},
	{"ID": 1003, "name": "王五", "age": 22}
]
```

### fastjson中的JSONObject

JSON代表JSONObject和JSONArray的转化

![](https://s2.loli.net/2022/04/08/tPgm9rhQekM4Ifn.png)

可以看出，JSONObject实现了Map接口，而JSON对象中的数据都是以“key : value”的形式出现，可以猜想，**JSONObject底层操作是由Map实现的**

#### getString()方法

![](https://s2.loli.net/2022/04/08/Dvh3nKijfVYwTsu.png)

内部主要是由get(key)的方法实现，内部主要由Map接口中的get()方法实现。

![](https://s2.loli.net/2022/04/08/CKP2cIaYA5LvdEb.png)

总结：JSONObject对应JSON对象，通过各种形式的get()方法可以获取JSON对象中的数据，也可利用诸如size()，isEmpty()等方法获取"键：值"对的个数和判断是否为空。其本质是通过实现Map接口并调用接口中的方法完成的。

### fastjson中的JSONArray

![](https://s2.loli.net/2022/04/08/6W7jcbaMGKqQFnd.png)

可见，JSONArray实现了List接口

JSON数组对象中存储的是一个个JSON对象，所以类中的方法主要用于直接操作JSON对象。比如这其中的add(),remove()，containsAll()方法，对应于JSON对象的添加，删除与判断。

### fastjson中的parseObject方法

该方法返回JSONObject对象，**用于实现json字符串向json对象的转化**，其内部调用了**parse()**方法，调用底层的**DefaultJSONParser**解析类进行转化，在转化失败时，抛出can not cast to JSONObject异常。

## Handler

### 什么是Handler

Handler是线程的消息通讯的桥梁，主要用来发送消息及处理消息。

handler通过**发送和处理Message和Runnable对象**来关联相对应线程的MessageQueue

- 可以让对应的Message和Runnable**在未来的某个时间点进行相应处理**
- 让自己想要处理的耗时操作放在子线程，让更新UI的操作放在主线程

![](https://camo.githubusercontent.com/425f5b25372b1af8b143e2497bc7b0e7650885cf3ce1521bbee7caa6be5675b0/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f34363435312d663536323465333466643730393162352e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

### Handler使用方法

- post（Runnable）**其实底层调用的还是sendMessage**，主要是系统自己封装了
- sendMessage（message）

### Handler机制原理

![](https://camo.githubusercontent.com/6a59645566832e666433e0ff30de244ff268e5873bcf3c4e22e3b696c76aa14d/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f34363435312d333164633733313632393837383463322e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)

handler，它的作用就是实现线程之间的通信。

handler整个流程中，主要有四个对象，handler，Message,MessageQueue,Looper。当应用创建的时候，就会在主线程中创建handler对象，

我们通过要传送的消息保存到Message中，handler通过调用sendMessage方法将Message发送到MessageQueue中，Looper对象就会不断的调用loop()方法不断的从MessageQueue中取出Message交给handler进行处理。从而实现线程之间的通信。

## View

#### View的绘制过程

```
  int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);
  int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);
  ...
  // 测量
  performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
  ...
  // 布局
  performLayout(lp, mWidth, mHeight);
  ...
  // 绘制
  performDraw();
```

Measure -> Layout -> Draw

#### 自定义view的基本流程

1、自定义View的属性 编写attr.xml文件 2、在layout布局文件中引用，同时引用命名空间 3、在View的构造方法中获得我们自定义的属性 ，在自定义控件中进行读取（构造方法拿到attr.xml文件值） 4、重写onMesure 5、重写onDraw
